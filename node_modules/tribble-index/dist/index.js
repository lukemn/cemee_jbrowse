'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.default = read;

var _parsers = require('./parsers');

var _parsers2 = _interopRequireDefault(_parsers);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var BaseIndex = function () {
  function BaseIndex(parsed) {
    _classCallCheck(this, BaseIndex);

    Object.assign(this, parsed);
  }

  _createClass(BaseIndex, null, [{
    key: 'regularizeChrName',
    value: function regularizeChrName(name) {
      return name.trim();
    }
  }]);

  return BaseIndex;
}();

var LinearBinnedIndex = function (_BaseIndex) {
  _inherits(LinearBinnedIndex, _BaseIndex);

  function LinearBinnedIndex(parsed) {
    _classCallCheck(this, LinearBinnedIndex);

    var _this = _possibleConstructorReturn(this, (LinearBinnedIndex.__proto__ || Object.getPrototypeOf(LinearBinnedIndex)).call(this, parsed));

    _this.type = 'linear';
    _this.chromosomeEntries = {};

    _this.firstDataOffset = Math.min.apply(Math, _toConsumableArray(_this.chromosomes.map(function (c) {
      return c.startPosition;
    })));

    _this.chromosomes.forEach(function (chr, i) {
      // convert the block positions into block start and size
      var currentPosition = chr.startPosition;
      chr.blocks.forEach(function (block) {
        var blockPosition = block.position;
        delete block.position;
        block.length = blockPosition - currentPosition;
        block.offset = currentPosition;
        currentPosition = blockPosition;
      });

      // record a mapping of chr name => index in the chromosomes array
      var regularizedName = LinearBinnedIndex.regularizeChrName(chr.name);
      var nameRecord = _this.chromosomeEntries[regularizedName];
      if (!nameRecord) {
        nameRecord = [];
        _this.chromosomeEntries[regularizedName] = nameRecord;
      }
      nameRecord.push(i);
    });
    return _this;
  }

  /**
   * Get an array of { offset, length } objects describing regions of the
   * indexed file containing data for the given range.
   *
   * @param {string} refName - name of the reference sequence
   * @param {integer} start - start coordinate of the range of interest
   * @param {integer} end - end coordinate of the range of interest
   */


  _createClass(LinearBinnedIndex, [{
    key: 'getBlocks',
    value: function getBlocks(refName, start, end) {
      var _this2 = this;

      var regularizedChrName = LinearBinnedIndex.regularizeChrName(refName);
      if (!this.chromosomeEntries[regularizedChrName]) return [];
      var blocks = [];
      this.chromosomeEntries[regularizedChrName].forEach(function (chrIndex) {
        var chr = _this2.chromosomes[chrIndex];
        // contiguous blocks are adjacent in a linear index,
        // so we can just combine them into one merged block

        var adjustedPosition = Math.max(start - chr.longestFeature, 0);
        var startBinNumber = Math.floor(adjustedPosition / chr.binWidth);
        if (startBinNumber >= chr.blocks.length) return;
        var endBinNumber = Math.min(Math.floor((end - 1) / chr.binWidth), chr.blocks.length - 1);

        var offset = chr.blocks[startBinNumber].offset;

        var length = chr.blocks[endBinNumber].offset + chr.blocks[endBinNumber].length - offset;
        if (length === 0) return;

        blocks.push({ offset: offset, length: length });
      });
      return blocks;
    }

    /**
     * Return true if the given reference sequence is present in the index,
     * false otherwise
     * @param {string} refName
     * @returns {boolean}
     */

  }, {
    key: 'hasRefSeq',
    value: function hasRefSeq(refName) {
      var regularizedChrName = LinearBinnedIndex.regularizeChrName(refName);
      return !!this.chromosomeEntries[regularizedChrName];
    }
  }]);

  return LinearBinnedIndex;
}(BaseIndex);

var IntervalTreeIndex = function (_BaseIndex2) {
  _inherits(IntervalTreeIndex, _BaseIndex2);

  function IntervalTreeIndex(parsed) {
    _classCallCheck(this, IntervalTreeIndex);

    var _this3 = _possibleConstructorReturn(this, (IntervalTreeIndex.__proto__ || Object.getPrototypeOf(IntervalTreeIndex)).call(this, parsed));

    _this3.type = 'interval_tree';
    return _this3;
  }

  _createClass(IntervalTreeIndex, [{
    key: 'getBlocks',
    value: function getBlocks() /* chrName, start, end */{
      this.hello = 1; // deleteme
      throw new Error('getBlocks not yet implemented for interval tree indexes. help wanted.');
    }
  }, {
    key: 'hasRefSeq',
    value: function hasRefSeq() /* refName */{
      this.hello = 1; // deleteme
      throw new Error('hasRefSeq not yet implemented for interval tree indexes. help wanted.');
    }
  }]);

  return IntervalTreeIndex;
}(BaseIndex);

/**
 * Parse the index from the given Buffer object. The buffer must contain
 * the entire index.
 *
 * @param {Buffer} input
 * @returns {LinearIndex|IntervalTreeIndex} an index object supporting the `getBlocks` method
 */


function read(input) {
  if (Buffer.isBuffer(input)) {
    var data = _parsers2.default.parse(input);
    if (data.type === 1) return new LinearBinnedIndex(data);else if (data.type === 2) return new IntervalTreeIndex(data);
    throw new Error('unsupported index type "' + data.type + '"');
  }

  throw new Error('unsupported input type, must be a Buffer containing the whole index');
}