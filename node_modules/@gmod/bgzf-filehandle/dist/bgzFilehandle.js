'use strict';var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);var _regenerator = require('babel-runtime/regenerator');var _regenerator2 = _interopRequireDefault(_regenerator);var _assign = require('babel-runtime/core-js/object/assign');var _assign2 = _interopRequireDefault(_assign);var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);var _createClass2 = require('babel-runtime/helpers/createClass');var _createClass3 = _interopRequireDefault(_createClass2);function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}var _require = require('./unzip'),unzip = _require.unzip;
var LocalFile = require('./localFile');
var GziIndex = require('./gziIndex');var

BgzFilehandle = function () {
  function BgzFilehandle(_ref) {var filehandle = _ref.filehandle,path = _ref.path,gziFilehandle = _ref.gziFilehandle,gziPath = _ref.gziPath;(0, _classCallCheck3.default)(this, BgzFilehandle);
    if (filehandle) this.filehandle = filehandle;else
    if (path) this.filehandle = new LocalFile(path);else
    throw new TypeError('either filehandle or path must be defined');

    if (!gziFilehandle && !gziPath && !path)
    throw new TypeError('either gziFilehandle or gziPath must be defined');
    if (!gziFilehandle && !gziPath && path) gziPath = path + '.gzi';

    this.gzi = new GziIndex({ filehandle: gziFilehandle, path: gziPath });
  }(0, _createClass3.default)(BgzFilehandle, [{ key: 'stat', value: function () {var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {var compressedStat;return _regenerator2.default.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:_context.next = 2;return (


                  this.filehandle.stat());case 2:compressedStat = _context.sent;_context.t0 = _assign2.default;_context.t1 =
                compressedStat;_context.next = 7;return (
                  this.getUncompressedFileSize());case 7:_context.t2 = _context.sent;_context.t3 =
                undefined;_context.t4 =
                undefined;_context.t5 = { size: _context.t2, blocks: _context.t3, blksize: _context.t4 };return _context.abrupt('return', (0, _context.t0)(_context.t1, _context.t5));case 12:case 'end':return _context.stop();}}}, _callee, this);}));function stat() {return _ref2.apply(this, arguments);}return stat;}() }, { key: 'getUncompressedFileSize', value: function () {var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2() {var _ref4, _ref5, uncompressedPosition, _ref6, size, buf, _ref7, bytesRead, lastBlockUncompressedSize;return _regenerator2.default.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:_context2.next = 2;return (






                  this.gzi.getLastBlock());case 2:_ref4 = _context2.sent;_ref5 = (0, _slicedToArray3.default)(_ref4, 2);uncompressedPosition = _ref5[1];_context2.next = 7;return (

                  this.filehandle.stat());case 7:_ref6 = _context2.sent;size = _ref6.size;

                buf = Buffer.allocUnsafe(4);
                // note: there should be a 28-byte EOF marker (an empty block) at
                // the end of the file, so we skip backward past that
                _context2.next = 12;return this.filehandle.read(buf, 0, 4, size - 28 - 4);case 12:_ref7 = _context2.sent;bytesRead = _ref7.bytesRead;if (!(
                bytesRead !== 4)) {_context2.next = 16;break;}throw new Error('read error');case 16:
                lastBlockUncompressedSize = buf.readUInt32LE(0);return _context2.abrupt('return',
                uncompressedPosition + lastBlockUncompressedSize);case 18:case 'end':return _context2.stop();}}}, _callee2, this);}));function getUncompressedFileSize() {return _ref3.apply(this, arguments);}return getUncompressedFileSize;}() }, { key: '_readAndUncompressBlock', value: function () {var _ref10 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3(



      blockBuffer, _ref8, _ref9) {var _ref12 = (0, _slicedToArray3.default)(_ref8, 1),
        compressedPosition = _ref12[0];var _ref11 = (0, _slicedToArray3.default)(_ref9, 1),
        nextCompressedPosition = _ref11[0];var blockCompressedLength, unzippedBuffer;return _regenerator2.default.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:if (

                nextCompressedPosition) {_context3.next = 4;break;}_context3.next = 3;return (
                  this.filehandle.stat());case 3:nextCompressedPosition = _context3.sent.size;case 4:


                // read the compressed data into the block buffer
                blockCompressedLength = nextCompressedPosition - compressedPosition;_context3.next = 7;return (

                  this.filehandle.read(
                  blockBuffer,
                  0,
                  blockCompressedLength,
                  compressedPosition));case 7:_context3.next = 9;return (



                  unzip(
                  blockBuffer.slice(0, blockCompressedLength)));case 9:unzippedBuffer = _context3.sent;return _context3.abrupt('return',


                unzippedBuffer);case 11:case 'end':return _context3.stop();}}}, _callee3, this);}));function _readAndUncompressBlock(_x, _x2, _x3) {return _ref10.apply(this, arguments);}return _readAndUncompressBlock;}() }, { key: 'read', value: function () {var _ref13 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee4(


      buf, offset, length, position) {var blockPositions, blockBuffer, destinationOffset, bytesRead, blockNum, uncompressedBuffer, _blockPositions$block, uncompressedPosition, sourceOffset, sourceEnd;return _regenerator2.default.wrap(function _callee4$(_context4) {while (1) {switch (_context4.prev = _context4.next) {case 0:_context4.next = 2;return (

                  this.gzi.getRelevantBlocksForRead(
                  length,
                  position));case 2:blockPositions = _context4.sent;

                blockBuffer = Buffer.allocUnsafe(32768 * 2);
                // uncompress the blocks and read from them one at a time to keep memory usage down
                destinationOffset = offset;
                bytesRead = 0;

                blockNum = 0;case 7:if (!(
                blockNum < blockPositions.length - 1)) {_context4.next = 18;break;}_context4.next = 10;return (


                  this._readAndUncompressBlock(
                  blockBuffer,
                  blockPositions[blockNum],
                  blockPositions[blockNum + 1]));case 10:uncompressedBuffer = _context4.sent;_blockPositions$block = (0, _slicedToArray3.default)(

                blockPositions[blockNum], 2), uncompressedPosition = _blockPositions$block[1];
                sourceOffset =
                uncompressedPosition >= position ? 0 : position - uncompressedPosition;
                sourceEnd =
                Math.min(
                position + length,
                uncompressedPosition + uncompressedBuffer.length) -
                uncompressedPosition;
                if (sourceOffset >= 0 && sourceOffset < uncompressedBuffer.length) {
                  uncompressedBuffer.copy(buf, destinationOffset, sourceOffset, sourceEnd);
                  destinationOffset += sourceEnd - sourceOffset;
                  bytesRead += sourceEnd - sourceOffset;
                }case 15:blockNum += 1;_context4.next = 7;break;case 18:return _context4.abrupt('return',


                { bytesRead: bytesRead, buffer: buf });case 19:case 'end':return _context4.stop();}}}, _callee4, this);}));function read(_x4, _x5, _x6, _x7) {return _ref13.apply(this, arguments);}return read;}() }]);return BgzFilehandle;}();



module.exports = BgzFilehandle;