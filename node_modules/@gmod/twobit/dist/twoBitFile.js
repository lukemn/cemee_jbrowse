'use strict';var _promise = require('babel-runtime/core-js/promise');var _promise2 = _interopRequireDefault(_promise);var _values = require('babel-runtime/core-js/object/values');var _values2 = _interopRequireDefault(_values);var _keys = require('babel-runtime/core-js/object/keys');var _keys2 = _interopRequireDefault(_keys);var _maxSafeInteger = require('babel-runtime/core-js/number/max-safe-integer');var _maxSafeInteger2 = _interopRequireDefault(_maxSafeInteger);var _regenerator = require('babel-runtime/regenerator');var _regenerator2 = _interopRequireDefault(_regenerator);var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);var _createClass2 = require('babel-runtime/helpers/createClass');var _createClass3 = _interopRequireDefault(_createClass2);var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}var Long = require('long');var _require =
require('binary-parser'),Parser = _require.Parser;

var fs =
// eslint-disable-next-line camelcase
typeof __webpack_require__ !== 'function' ? require('fs-extra') : undefined;

var TWOBIT_MAGIC = 0x1a412743;

function tinyMemoize(_class, methodName) {
  var method = _class.prototype[methodName];
  var memoAttrName = '_memo_' + methodName;
  _class.prototype[methodName] = function _tinyMemoized() {
    if (!(memoAttrName in this)) this[memoAttrName] = method.call(this);
    return this[memoAttrName];
  };
}

var twoBit = ['T', 'C', 'A', 'G'];
// byteTo4Bases is an array of byteValue -> 'ACTG'
// the weird `...keys()` incantation generates an array of numbers 0 to 255
var byteTo4Bases = [].concat((0, _toConsumableArray3.default)(Array(256).keys())).map(
function (x, i) {return (
    twoBit[i >> 6 & 3] +
    twoBit[i >> 4 & 3] +
    twoBit[i >> 2 & 3] +
    twoBit[i & 3]);});

var maskedByteTo4Bases = byteTo4Bases.map(function (bases) {return bases.toLowerCase();});

// LocalFile is pretty much just an implementation of the node 10+ fs.promises filehandle,
// can switch to that when the API is stable
var LocalFile = function () {
  function LocalFile(path) {(0, _classCallCheck3.default)(this, LocalFile);
    this.fdPromise = fs.open(path, 'r');
  }(0, _createClass3.default)(LocalFile, [{ key: 'read', value: function () {var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(

      buf, offset, length, position) {var fd;return _regenerator2.default.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:_context.next = 2;return (
                  this.fdPromise);case 2:fd = _context.sent;_context.next = 5;return (
                  fs.read(fd, buf, offset, length, position));case 5:case 'end':return _context.stop();}}}, _callee, this);}));function read(_x, _x2, _x3, _x4) {return _ref.apply(this, arguments);}return read;}() }]);return LocalFile;}();var



TwoBitFile = function () {
  /**
                           * @param {object} args
                           * @param {string} [args.path] filesystem path for the .2bit file to open
                           * @param {Filehandle} [args.filehandle] node fs.promises-like filehandle for the .2bit file.
                           *  Only needs to support `filehandle.read(buffer, offset, length, position)`
                           */
  function TwoBitFile(_ref2) {var filehandle = _ref2.filehandle,path = _ref2.path,seqChunkSize = _ref2.seqChunkSize;(0, _classCallCheck3.default)(this, TwoBitFile);
    if (filehandle) this.filehandle = filehandle;else
    if (path) this.filehandle = new LocalFile(path);
    this.isBigEndian = undefined;
    this.seqChunkSize = seqChunkSize || 32000;
  }(0, _createClass3.default)(TwoBitFile, [{ key: '_getParser', value: function () {var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(

      name) {var parser;return _regenerator2.default.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:_context2.next = 2;return (
                  this._getParsers());case 2:_context2.t0 = name;parser = _context2.sent[_context2.t0];if (
                parser) {_context2.next = 6;break;}throw new Error('parser ' + name + ' not found');case 6:return _context2.abrupt('return',
                parser);case 7:case 'end':return _context2.stop();}}}, _callee2, this);}));function _getParser(_x5) {return _ref3.apply(this, arguments);}return _getParser;}() }, { key: '_detectEndianness', value: function () {var _ref4 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3() {var buf;return _regenerator2.default.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:



                buf = Buffer.allocUnsafe(8);_context3.next = 3;return (
                  this.filehandle.read(buf, 0, 8, 0));case 3:if (!(
                buf.readInt32LE(0) === TWOBIT_MAGIC)) {_context3.next = 8;break;}
                this.isBigEndian = false;
                this.version = buf.readInt32LE(4);_context3.next = 14;break;case 8:if (!(
                buf.readInt32BE(0) === TWOBIT_MAGIC)) {_context3.next = 13;break;}
                this.isBigEndian = true;
                this.version = buf.readInt32BE(4);_context3.next = 14;break;case 13:throw (

                  new Error('not a 2bit file'));case 14:case 'end':return _context3.stop();}}}, _callee3, this);}));function _detectEndianness() {return _ref4.apply(this, arguments);}return _detectEndianness;}()



    // memoize
    /**
     * @private
     * detects the file's endianness and instantiates our binary parsers accordingly
     */ }, { key: '_getParsers', value: function () {var _ref5 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee4() {var endianess, lebe, indexEntryParser;return _regenerator2.default.wrap(function _callee4$(_context4) {while (1) {switch (_context4.prev = _context4.next) {case 0:_context4.next = 2;return (

                  this._detectEndianness());case 2:

                endianess = this.isBigEndian ? 'big' : 'little';
                lebe = this.isBigEndian ? 'be' : 'le';

                indexEntryParser = new Parser().
                endianess(endianess).
                uint8('nameLength').
                string('name', { length: 'nameLength' });
                if (this.version === 1) {
                  indexEntryParser = indexEntryParser.buffer('offsetBytes', {
                    length: 8 });

                } else {
                  indexEntryParser = indexEntryParser.uint32('offset');
                }return _context4.abrupt('return',
                {
                  header: new Parser().
                  endianess(endianess).
                  int32('magic', {
                    assert: function assert(m) {return m === 0x1a412743;} }).

                  int32('version', {
                    assert: function assert(v) {return v === 0 || v === 1;} }).

                  uint32('sequenceCount', {
                    assert: function assert(v) {return v >= 0;} }).

                  uint32('reserved'),
                  index: new Parser().
                  endianess(endianess).
                  uint32('sequenceCount').
                  uint32('reserved').
                  array('index', {
                    length: 'sequenceCount',
                    type: indexEntryParser }),

                  record1: new Parser().
                  endianess(endianess).
                  uint32('dnaSize').
                  uint32('nBlockCount'),
                  record2: new Parser().
                  endianess(endianess).
                  uint32('nBlockCount').
                  array('nBlockStarts', {
                    length: 'nBlockCount',
                    type: 'uint32' + lebe }).

                  array('nBlockSizes', {
                    length: 'nBlockCount',
                    type: 'uint32' + lebe }).

                  uint32('maskBlockCount'),
                  record3: new Parser().
                  endianess(endianess).
                  uint32('maskBlockCount').
                  array('maskBlockStarts', {
                    length: 'maskBlockCount',
                    type: 'uint32' + lebe }).

                  array('maskBlockSizes', {
                    length: 'maskBlockCount',
                    type: 'uint32' + lebe }).

                  int32('reserved')
                  // .buffer('packedDna', { length: 'dnaSize' }),
                });case 7:case 'end':return _context4.stop();}}}, _callee4, this);}));function _getParsers() {return _ref5.apply(this, arguments);}return _getParsers;}()


    // memoize
    /**
     * @returns {Promise} for object with the file's header information, like
     *  `{ magic: 0x1a412743, version: 0, sequenceCount: 42, reserved: 0 }`
     */ }, { key: 'getHeader', value: function () {var _ref6 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee5() {var buf, headerParser;return _regenerator2.default.wrap(function _callee5$(_context5) {while (1) {switch (_context5.prev = _context5.next) {case 0:_context5.next = 2;return (

                  this._detectEndianness());case 2:

                buf = Buffer.allocUnsafe(16);_context5.next = 5;return (
                  this.filehandle.read(buf, 0, 16, 0));case 5:_context5.next = 7;return (

                  this._getParser('header'));case 7:headerParser = _context5.sent;return _context5.abrupt('return',
                headerParser.parse(buf));case 9:case 'end':return _context5.stop();}}}, _callee5, this);}));function getHeader() {return _ref6.apply(this, arguments);}return getHeader;}()


    // memoize
    /**
     * @returns {Promise} for object with the file's index of offsets, like `{ seqName: fileOffset, ...}`
     */ }, { key: 'getIndex', value: function () {var _ref7 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee6() {var _this = this;var header, maxIndexLength, buf, indexParser, indexData, index;return _regenerator2.default.wrap(function _callee6$(_context6) {while (1) {switch (_context6.prev = _context6.next) {case 0:_context6.next = 2;return (

                  this.getHeader());case 2:header = _context6.sent;
                maxIndexLength =
                8 + header.sequenceCount * (1 + 256 + (this.version === 1 ? 8 : 4));
                buf = Buffer.allocUnsafe(maxIndexLength);_context6.next = 7;return (
                  this.filehandle.read(buf, 0, maxIndexLength, 8));case 7:_context6.next = 9;return (
                  this._getParser('index'));case 9:indexParser = _context6.sent;
                indexData = indexParser.parse(buf).index;
                index = {};
                if (this.version === 1) {
                  indexData.forEach(function (_ref8) {var name = _ref8.name,offsetBytes = _ref8.offsetBytes;
                    var long = Long.fromBytes(offsetBytes, true, !_this.isBigEndian);
                    if (long.greaterThan(_maxSafeInteger2.default))
                    throw new Error(
                    'integer overflow. File offset greater than 2^53-1 encountered. This library can only handle offsets up to 2^53-1.');

                    index[name] = long.toNumber();
                  });
                } else {
                  indexData.forEach(function (_ref9) {var name = _ref9.name,offset = _ref9.offset;
                    index[name] = offset;
                  });
                }return _context6.abrupt('return',
                index);case 14:case 'end':return _context6.stop();}}}, _callee6, this);}));function getIndex() {return _ref7.apply(this, arguments);}return getIndex;}()


    /**
                                                                                                                                                                          * @returns {Promise} for an array of string sequence names that are found in the file
                                                                                                                                                                          */ }, { key: 'getSequenceNames', value: function () {var _ref10 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee7() {var index;return _regenerator2.default.wrap(function _callee7$(_context7) {while (1) {switch (_context7.prev = _context7.next) {case 0:_context7.next = 2;return (

                  this.getIndex());case 2:index = _context7.sent;return _context7.abrupt('return',
                (0, _keys2.default)(index));case 4:case 'end':return _context7.stop();}}}, _callee7, this);}));function getSequenceNames() {return _ref10.apply(this, arguments);}return getSequenceNames;}()


    /**
                                                                                                                                                                                                               * @returns {Promise} for an object listing the lengths of all sequences like `{seqName: length, ...}`
                                                                                                                                                                                                               */ }, { key: 'getSequenceSizes', value: function () {var _ref11 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee8() {var _this2 = this;var index, seqNames, sizePromises, sizes, returnObject, i;return _regenerator2.default.wrap(function _callee8$(_context8) {while (1) {switch (_context8.prev = _context8.next) {case 0:_context8.next = 2;return (

                  this.getIndex());case 2:index = _context8.sent;
                seqNames = (0, _keys2.default)(index);
                sizePromises = (0, _values2.default)(index).map(function (offset) {return (
                    _this2._getSequenceSize(offset));});_context8.next = 7;return (

                  _promise2.default.all(sizePromises));case 7:sizes = _context8.sent;
                returnObject = {};
                for (i = 0; i < seqNames.length; i += 1) {
                  returnObject[seqNames[i]] = sizes[i];
                }return _context8.abrupt('return',
                returnObject);case 11:case 'end':return _context8.stop();}}}, _callee8, this);}));function getSequenceSizes() {return _ref11.apply(this, arguments);}return getSequenceSizes;}()


    /**
                                                                                                                                                                                                  * @param {string} seqName name of the sequence
                                                                                                                                                                                                  * @returns {Promise} for the sequence's length, or undefined if it is not in the file
                                                                                                                                                                                                  */ }, { key: 'getSequenceSize', value: function () {var _ref12 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee9(
      seqName) {var index, offset;return _regenerator2.default.wrap(function _callee9$(_context9) {while (1) {switch (_context9.prev = _context9.next) {case 0:_context9.next = 2;return (
                  this.getIndex());case 2:index = _context9.sent;
                offset = index[seqName];if (
                offset) {_context9.next = 6;break;}return _context9.abrupt('return', undefined);case 6:return _context9.abrupt('return',
                this._getSequenceSize(offset));case 7:case 'end':return _context9.stop();}}}, _callee9, this);}));function getSequenceSize(_x6) {return _ref12.apply(this, arguments);}return getSequenceSize;}() }, { key: '_getSequenceSize', value: function () {var _ref13 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee10(


      offset) {var rec1;return _regenerator2.default.wrap(function _callee10$(_context10) {while (1) {switch (_context10.prev = _context10.next) {case 0:if (!(

                offset === undefined || offset < 0)) {_context10.next = 2;break;}throw new Error('invalid offset');case 2:_context10.next = 4;return (
                  this._parseItem(offset, 8, 'record1'));case 4:rec1 = _context10.sent;return _context10.abrupt('return',
                rec1.dnaSize);case 6:case 'end':return _context10.stop();}}}, _callee10, this);}));function _getSequenceSize(_x7) {return _ref13.apply(this, arguments);}return _getSequenceSize;}() }, { key: '_getSequenceRecord', value: function () {var _ref14 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee11(


      offset) {var rec1, rec2DataLength, rec2, rec3DataLength, rec3, rec;return _regenerator2.default.wrap(function _callee11$(_context11) {while (1) {switch (_context11.prev = _context11.next) {case 0:if (!(

                offset === undefined || offset < 0)) {_context11.next = 2;break;}throw new Error('invalid offset');case 2:_context11.next = 4;return (
                  this._parseItem(offset, 8, 'record1'));case 4:rec1 = _context11.sent;
                rec2DataLength = rec1.nBlockCount * 8 + 8;_context11.next = 8;return (
                  this._parseItem(offset + 4, rec2DataLength, 'record2'));case 8:rec2 = _context11.sent;
                rec3DataLength = rec2.maskBlockCount * 8 + 8;_context11.next = 12;return (
                  this._parseItem(
                  offset + 4 + rec2DataLength - 4,
                  rec3DataLength,
                  'record3'));case 12:rec3 = _context11.sent;


                rec = {
                  dnaSize: rec1.dnaSize,
                  nBlocks: { starts: rec2.nBlockStarts, sizes: rec2.nBlockSizes },
                  maskBlocks: { starts: rec3.maskBlockStarts, sizes: rec3.maskBlockSizes },
                  dnaPosition: offset + 4 + rec2DataLength - 4 + rec3DataLength };return _context11.abrupt('return',

                rec);case 15:case 'end':return _context11.stop();}}}, _callee11, this);}));function _getSequenceRecord(_x8) {return _ref14.apply(this, arguments);}return _getSequenceRecord;}() }, { key: '_parseItem', value: function () {var _ref15 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee12(


      offset, length, parserName) {var buf, parser;return _regenerator2.default.wrap(function _callee12$(_context12) {while (1) {switch (_context12.prev = _context12.next) {case 0:
                buf = Buffer.allocUnsafe(length);_context12.next = 3;return (
                  this.filehandle.read(buf, 0, length, offset));case 3:_context12.next = 5;return (
                  this._getParser(parserName));case 5:parser = _context12.sent;return _context12.abrupt('return',
                parser.parse(buf));case 7:case 'end':return _context12.stop();}}}, _callee12, this);}));function _parseItem(_x9, _x10, _x11) {return _ref15.apply(this, arguments);}return _parseItem;}()


    /**
                                                                                                                                                                                                           * @param {string} seqName name of the sequence you want
                                                                                                                                                                                                           * @param {number} [regionStart] optional 0-based half-open start of the sequence region to fetch.
                                                                                                                                                                                                           * @param {number} [regionEnd] optional 0-based half-open end of the sequence region to fetch. defaults to end of the sequence
                                                                                                                                                                                                           * @returns {Promise} for a string of sequence bases
                                                                                                                                                                                                           */ }, { key: 'getSequence', value: function () {var _ref16 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee13(
      seqName) {var regionStart = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var regionEnd = arguments[2];var index, offset, record, nBlocks, maskBlocks, baseBytes, baseBytesOffset, sequenceBases, genomicPosition, baseIsMasked, currentNBlock, bytePosition, subPosition, byte;return _regenerator2.default.wrap(function _callee13$(_context13) {while (1) {switch (_context13.prev = _context13.next) {case 0:_context13.next = 2;return (
                  this.getIndex());case 2:index = _context13.sent;
                offset = index[seqName];if (
                offset) {_context13.next = 6;break;}return _context13.abrupt('return',
                undefined);case 6:_context13.next = 8;return (


                  this._getSequenceRecord(offset));case 8:record = _context13.sent;if (!(

                regionStart < 0)) {_context13.next = 11;break;}throw (
                  new TypeError('regionStart cannot be less than 0'));case 11:

                // end defaults to the end of the sequence
                if (regionEnd === undefined || regionEnd > record.dnaSize) {
                  regionEnd = record.dnaSize;
                }

                nBlocks = this._getOverlappingBlocks(
                regionStart,
                regionEnd,
                record.nBlocks.starts,
                record.nBlocks.sizes);

                maskBlocks = this._getOverlappingBlocks(
                regionStart,
                regionEnd,
                record.maskBlocks.starts,
                record.maskBlocks.sizes);


                baseBytes = Buffer.allocUnsafe(
                Math.ceil((regionEnd - regionStart) / 4) + 1);

                baseBytesOffset = Math.floor(regionStart / 4);_context13.next = 18;return (
                  this.filehandle.read(
                  baseBytes,
                  0,
                  baseBytes.length,
                  record.dnaPosition + baseBytesOffset));case 18:


                sequenceBases = '';
                for (
                genomicPosition = regionStart;
                genomicPosition < regionEnd;
                genomicPosition += 1)
                {
                  // check whether we are currently masked
                  while (maskBlocks.length && maskBlocks[0].end <= genomicPosition) {
                    maskBlocks.shift();}
                  baseIsMasked =
                  maskBlocks[0] &&
                  maskBlocks[0].start <= genomicPosition &&
                  maskBlocks[0].end > genomicPosition;

                  // process the N block if we have one
                  if (
                  nBlocks[0] &&
                  genomicPosition >= nBlocks[0].start &&
                  genomicPosition < nBlocks[0].end)
                  {
                    currentNBlock = nBlocks.shift();
                    for (;

                    genomicPosition < currentNBlock.end && genomicPosition < regionEnd;
                    genomicPosition += 1)
                    {
                      sequenceBases += baseIsMasked ? 'n' : 'N';
                    }
                    genomicPosition -= 1;
                  } else {
                    bytePosition = Math.floor(genomicPosition / 4) - baseBytesOffset;
                    subPosition = genomicPosition % 4;
                    byte = baseBytes[bytePosition];
                    sequenceBases += baseIsMasked ?
                    maskedByteTo4Bases[byte][subPosition] :
                    byteTo4Bases[byte][subPosition];
                  }
                }return _context13.abrupt('return',

                sequenceBases);case 21:case 'end':return _context13.stop();}}}, _callee13, this);}));function getSequence(_x13) {return _ref16.apply(this, arguments);}return getSequence;}() }, { key: '_getOverlappingBlocks', value: function _getOverlappingBlocks(


    regionStart, regionEnd, blockStarts, blockSizes) {
      // find the start and end indexes of the blocks that match
      var startIndex = void 0;
      var endIndex = void 0;
      for (var i = 0; i < blockStarts.length; i += 1) {
        var blockStart = blockStarts[i];
        var blockSize = blockSizes[i];
        if (regionStart >= blockStart + blockSize || regionEnd <= blockStart) {
          // block does not overlap the region
          if (startIndex !== undefined) {
            endIndex = i;
            break;
          }
        } else if (startIndex === undefined) startIndex = i; // block does overlap the region, record this if it is the first
      }

      if (startIndex === undefined) return [];

      // now format some block objects to return
      if (endIndex === undefined) endIndex = blockStarts.length;

      var blocks = new Array(endIndex - startIndex);
      for (var blockNum = startIndex; blockNum < endIndex; blockNum += 1) {
        blocks[blockNum - startIndex] = {
          start: blockStarts[blockNum],
          end: blockStarts[blockNum] + blockSizes[blockNum],
          size: blockSizes[blockNum] };

      }
      return blocks;
    } }]);return TwoBitFile;}();


tinyMemoize(TwoBitFile, '_getParsers');
tinyMemoize(TwoBitFile, 'getIndex');
tinyMemoize(TwoBitFile, 'getHeader');

module.exports = TwoBitFile;