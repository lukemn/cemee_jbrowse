'use strict';var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);var _createClass2 = require('babel-runtime/helpers/createClass');var _createClass3 = _interopRequireDefault(_createClass2);function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}var VirtualOffset = function () {
  function VirtualOffset(blockPosition, dataPosition) {(0, _classCallCheck3.default)(this, VirtualOffset);
    this.blockPosition = blockPosition; // < offset of the compressed data block
    this.dataPosition = dataPosition; // < offset into the uncompressed data
  }(0, _createClass3.default)(VirtualOffset, [{ key: 'toString', value: function toString()
















    {
      return this.blockPosition + ':' + this.dataPosition;
    } }, { key: 'compareTo', value: function compareTo(
    b) {
      return (
        this.blockPosition - b.blockPosition || this.dataPosition - b.dataPosition);

    } }], [{ key: 'fromBytes', value: function fromBytes(bytes) {var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var bigendian = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;if (bigendian) throw new Error('big-endian virtual file offsets not implemented');return new VirtualOffset(bytes[offset + 7] * 0x10000000000 + bytes[offset + 6] * 0x100000000 + bytes[offset + 5] * 0x1000000 + bytes[offset + 4] * 0x10000 + bytes[offset + 3] * 0x100 + bytes[offset + 2], bytes[offset + 1] << 8 | bytes[offset]);} }, { key: 'min', value: function min()

    {
      var min = void 0;
      var i = 0;
      for (; !min; i += 1) {min = arguments.length <= i ? undefined : arguments[i];}
      for (; i < arguments.length; i += 1) {
        if (min.compareTo(arguments.length <= i ? undefined : arguments[i]) > 0) min = arguments.length <= i ? undefined : arguments[i];
      }
      return min;
    } }]);return VirtualOffset;}();


module.exports = VirtualOffset;