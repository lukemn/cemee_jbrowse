'use strict';var _assign = require('babel-runtime/core-js/object/assign');var _assign2 = _interopRequireDefault(_assign);var _regenerator = require('babel-runtime/regenerator');var _regenerator2 = _interopRequireDefault(_regenerator);var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);var _createClass2 = require('babel-runtime/helpers/createClass');var _createClass3 = _interopRequireDefault(_createClass2);function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}var Long = require('long');
// const { Parser } = require('binary-parser')
var VirtualOffset = require('./virtualOffset');
var Chunk = require('./chunk');var _require =

require('./unzip'),unzip = _require.unzip;

var TBI_MAGIC = 21578324; // TBI\1
var TAD_LIDX_SHIFT = 14;var _require2 =

require('./util'),longToNumber = _require2.longToNumber;

/**
                                                          * calculate the list of bins that may overlap with region [beg,end) (zero-based half-open)
                                                          * @returns {Array[number]}
                                                          */
function reg2bins(beg, end) {
  beg += 1; // < convert to 1-based closed
  end -= 1;
  var list = [0];
  for (var k = 1 + (beg >> 26); k <= 1 + (end >> 26); k += 1) {list.push(k);}
  for (var _k = 9 + (beg >> 23); _k <= 9 + (end >> 23); _k += 1) {list.push(_k);}
  for (var _k2 = 73 + (beg >> 20); _k2 <= 73 + (end >> 20); _k2 += 1) {list.push(_k2);}
  for (var _k3 = 585 + (beg >> 17); _k3 <= 585 + (end >> 17); _k3 += 1) {list.push(_k3);}
  for (var _k4 = 4681 + (beg >> 14); _k4 <= 4681 + (end >> 14); _k4 += 1) {list.push(_k4);}
  return list;
}var

TabixIndex = function () {
  /**
                           * @param {filehandle} filehandle
                           * @param {function} [renameRefSeqs]
                           */
  function TabixIndex(_ref) {var filehandle = _ref.filehandle,_ref$renameRefSeqs = _ref.renameRefSeqs,renameRefSeqs = _ref$renameRefSeqs === undefined ? function (n) {return n;} : _ref$renameRefSeqs;(0, _classCallCheck3.default)(this, TabixIndex);
    this.filehandle = filehandle;
    this.renameRefSeq = renameRefSeqs;
  }(0, _createClass3.default)(TabixIndex, [{ key: 'lineCount', value: function () {var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(

      refName) {var indexData, refId, idx, stats;return _regenerator2.default.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:_context.next = 2;return (
                  this.parse());case 2:indexData = _context.sent;if (
                indexData) {_context.next = 5;break;}return _context.abrupt('return', -1);case 5:
                refId = indexData.refNameToId[refName];
                idx = indexData.indices[refId];if (
                idx) {_context.next = 9;break;}return _context.abrupt('return', -1);case 9:
                stats = indexData.indices[refId].stats;if (!
                stats) {_context.next = 12;break;}return _context.abrupt('return', stats.lineCount);case 12:return _context.abrupt('return',
                -1);case 13:case 'end':return _context.stop();}}}, _callee, this);}));function lineCount(_x) {return _ref2.apply(this, arguments);}return lineCount;}()


    /**
                                                                                                                                                                         * @returns {Promise} for an object like
                                                                                                                                                                         * `{ columnNumbers, metaChar, skipLines, refIdToName, refNameToId, coordinateType, format }`
                                                                                                                                                                         */ }, { key: 'getMetadata', value: function () {var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2() {var _ref4, columnNumbers, metaChar, format, coordinateType, skipLines, refIdToName, refNameToId, firstDataLine, maxBlockSize;return _regenerator2.default.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:_context2.next = 2;return (











                  this.parse());case 2:_ref4 = _context2.sent;columnNumbers = _ref4.columnNumbers;metaChar = _ref4.metaChar;format = _ref4.format;coordinateType = _ref4.coordinateType;skipLines = _ref4.skipLines;refIdToName = _ref4.refIdToName;refNameToId = _ref4.refNameToId;firstDataLine = _ref4.firstDataLine;maxBlockSize = _ref4.maxBlockSize;return _context2.abrupt('return',
                {
                  columnNumbers: columnNumbers,
                  metaChar: metaChar,
                  format: format,
                  coordinateType: coordinateType,
                  skipLines: skipLines,
                  refIdToName: refIdToName,
                  refNameToId: refNameToId,
                  firstDataLine: firstDataLine,
                  maxBlockSize: maxBlockSize,
                  maxBinNumber: ((1 << 18) - 1) / 7 });case 13:case 'end':return _context2.stop();}}}, _callee2, this);}));function getMetadata() {return _ref3.apply(this, arguments);}return getMetadata;}()



    // memoize
    // fetch and parse the index
  }, { key: 'parse', value: function () {var _ref5 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3() {var data, bytes, nameSectionLength, names, currOffset, i, binCount, binIndex, stats, j, bin, chunkCount, chunks, k, u, v, linearCount, linearIndex, _k5;return _regenerator2.default.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:
                data = { depth: 5, maxBlockSize: 1 << 16 };_context3.t0 =
                unzip;_context3.next = 4;return this.filehandle.readFile();case 4:_context3.t1 = _context3.sent;_context3.next = 7;return (0, _context3.t0)(_context3.t1);case 7:bytes = _context3.sent;if (!(


                bytes.readUInt32LE(0) !== TBI_MAGIC /* "TBI\1" */)) {_context3.next = 10;break;}throw (
                  new Error('Not a TBI file'));case 10:



                // number of reference sequences in the index
                data.refCount = bytes.readInt32LE(4);
                data.formatFlags = bytes.readInt32LE(8);
                data.coordinateType =
                data.formatFlags & 0x10000 ? 'zero-based-half-open' : '1-based-closed';
                data.format = { 0: 'generic', 1: 'SAM', 2: 'VCF' }[data.formatFlags & 0xf];if (
                data.format) {_context3.next = 16;break;}throw (
                  new Error('invalid Tabix preset format flags ' + data.formatFlags));case 16:
                data.columnNumbers = {
                  ref: bytes.readInt32LE(12),
                  start: bytes.readInt32LE(16),
                  end: bytes.readInt32LE(20) };

                data.metaValue = bytes.readInt32LE(24);
                data.depth = 5;
                data.maxBinNumber = ((1 << (data.depth + 1) * 3) - 1) / 7;
                data.metaChar = data.metaValue ? String.fromCharCode(data.metaValue) : null;
                data.skipLines = bytes.readInt32LE(28);

                // read sequence dictionary
                nameSectionLength = bytes.readInt32LE(32);
                names = this._parseNameBytes(bytes.slice(36, 36 + nameSectionLength));
                (0, _assign2.default)(data, names);

                // read the indexes for each reference sequence
                data.indices = new Array(data.refCount);
                currOffset = 36 + nameSectionLength;
                for (i = 0; i < data.refCount; i += 1) {
                  // the binning index
                  binCount = bytes.readInt32LE(currOffset);
                  currOffset += 4;
                  binIndex = {};
                  stats = void 0;
                  for (j = 0; j < binCount; j += 1) {
                    bin = bytes.readUInt32LE(currOffset);
                    if (bin > data.maxBinNumber) {
                      stats = this.parsePseudoBin(bytes, currOffset + 4);
                      currOffset += 8 + 2 * 16;
                    } else {
                      chunkCount = bytes.readInt32LE(currOffset + 4);
                      chunks = new Array(chunkCount);
                      currOffset += 8;
                      for (k = 0; k < chunkCount; k += 1) {
                        u = VirtualOffset.fromBytes(bytes, currOffset);
                        v = VirtualOffset.fromBytes(bytes, currOffset + 8);
                        currOffset += 16;
                        data.firstDataLine = VirtualOffset.min(data.firstDataLine, u);
                        chunks[k] = new Chunk(u, v, bin);
                      }
                      binIndex[bin] = chunks;
                    }
                  }

                  // the linear index
                  linearCount = bytes.readInt32LE(currOffset);
                  currOffset += 4;
                  linearIndex = new Array(linearCount);
                  for (_k5 = 0; _k5 < linearCount; _k5 += 1) {
                    linearIndex[_k5] = VirtualOffset.fromBytes(bytes, currOffset);
                    currOffset += 8;
                    data.firstDataLine = VirtualOffset.min(
                    data.firstDataLine,
                    linearIndex[_k5]);

                  }

                  data.indices[i] = { binIndex: binIndex, linearIndex: linearIndex, stats: stats };
                }return _context3.abrupt('return',

                data);case 29:case 'end':return _context3.stop();}}}, _callee3, this);}));function parse() {return _ref5.apply(this, arguments);}return parse;}() }, { key: 'parsePseudoBin', value: function parsePseudoBin(


    bytes, offset) {
      // const one = Long.fromBytesLE(bytes.slice(offset + 4, offset + 12), true)
      // const two = Long.fromBytesLE(bytes.slice(offset + 12, offset + 20), true)
      var lineCount = longToNumber(
      Long.fromBytesLE(bytes.slice(offset + 20, offset + 28), true));

      // const four = Long.fromBytesLE(bytes.slice(offset + 28, offset + 36), true)
      return { lineCount: lineCount };
    } }, { key: '_parseNameBytes', value: function _parseNameBytes(

    namesBytes) {
      var currRefId = 0;
      var currNameStart = 0;
      var refIdToName = [];
      var refNameToId = {};
      for (var i = 0; i < namesBytes.length; i += 1) {
        if (!namesBytes[i]) {
          if (currNameStart < i) {
            var refName = namesBytes.toString('utf8', currNameStart, i);
            refName = this.renameRefSeq(refName);
            refIdToName[currRefId] = refName;
            refNameToId[refName] = currRefId;
          }
          currNameStart = i + 1;
          currRefId += 1;
        }
      }
      return { refNameToId: refNameToId, refIdToName: refIdToName };
    } }, { key: 'blocksForRange', value: function () {var _ref6 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee4(

      refName, beg, end) {var indexData, refId, indexes, linearIndex, binIndex, bins, minOffset, l, numOffsets, i, off, _i, chunks, j, _i2, _i3, _i4;return _regenerator2.default.wrap(function _callee4$(_context4) {while (1) {switch (_context4.prev = _context4.next) {case 0:
                if (beg < 0) beg = 0;_context4.next = 3;return (

                  this.parse());case 3:indexData = _context4.sent;if (
                indexData) {_context4.next = 6;break;}return _context4.abrupt('return', []);case 6:
                refId = indexData.refNameToId[refName];
                indexes = indexData.indices[refId];if (
                indexes) {_context4.next = 10;break;}return _context4.abrupt('return', []);case 10:

                linearIndex = indexes.linearIndex, binIndex = indexes.binIndex;

                bins = reg2bins(beg, end);

                minOffset = linearIndex.length ?
                linearIndex[
                beg >> TAD_LIDX_SHIFT >= linearIndex.length ?
                linearIndex.length - 1 :
                beg >> TAD_LIDX_SHIFT] :

                new VirtualOffset(0, 0);

                l = void 0;
                numOffsets = 0;
                for (i = 0; i < bins.length; i += 1) {
                  if (binIndex[bins[i]]) numOffsets += binIndex[bins[i]].length;
                }if (!(

                numOffsets === 0)) {_context4.next = 18;break;}return _context4.abrupt('return', []);case 18:

                off = [];
                numOffsets = 0;
                for (_i = 0; _i < bins.length; _i += 1) {
                  chunks = binIndex[bins[_i]];
                  if (chunks)
                  for (j = 0; j < chunks.length; j += 1) {
                    if (minOffset.compareTo(chunks[j].maxv) < 0) {
                      off[numOffsets] = new Chunk(
                      chunks[j].minv,
                      chunks[j].maxv,
                      chunks[j].bin);

                      numOffsets += 1;
                    }}
                }if (

                off.length) {_context4.next = 23;break;}return _context4.abrupt('return', []);case 23:

                off = off.sort(function (a, b) {return a.compareTo(b);});

                // resolve completely contained adjacent blocks
                l = 0;
                for (_i2 = 1; _i2 < numOffsets; _i2 += 1) {
                  if (off[l].maxv.compareTo(off[_i2].maxv) < 0) {
                    l += 1;
                    off[l].minv = off[_i2].minv;
                    off[l].maxv = off[_i2].maxv;
                  }
                }
                numOffsets = l + 1;

                // resolve overlaps between adjacent blocks; this may happen due to the merge in indexing
                for (_i3 = 1; _i3 < numOffsets; _i3 += 1) {
                  if (off[_i3 - 1].maxv.compareTo(off[_i3].minv) >= 0)
                  off[_i3 - 1].maxv = off[_i3].minv;}
                // merge adjacent blocks
                l = 0;
                for (_i4 = 1; _i4 < numOffsets; _i4 += 1) {
                  if (off[l].maxv.blockPosition === off[_i4].minv.blockPosition)
                  off[l].maxv = off[_i4].maxv;else
                  {
                    l += 1;
                    off[l].minv = off[_i4].minv;
                    off[l].maxv = off[_i4].maxv;
                  }
                }
                numOffsets = l + 1;return _context4.abrupt('return',

                off.slice(0, numOffsets));case 32:case 'end':return _context4.stop();}}}, _callee4, this);}));function blocksForRange(_x2, _x3, _x4) {return _ref6.apply(this, arguments);}return blocksForRange;}() }]);return TabixIndex;}();



// this is the stupidest possible memoization, ignores arguments.
function tinyMemoize(_class, methodName) {
  var method = _class.prototype[methodName];
  if (!method)
  throw new Error('no method ' + methodName + ' found in class ' + _class.name);
  var memoAttrName = '_memo_' + methodName;
  _class.prototype[methodName] = function _tinyMemoized() {
    if (!(memoAttrName in this)) this[memoAttrName] = method.call(this);
    return this[memoAttrName];
  };
}
// memoize index.parse()
tinyMemoize(TabixIndex, 'parse');

module.exports = TabixIndex;