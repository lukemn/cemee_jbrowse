'use strict';

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _require = require('./errors'),
    CramUnimplementedError = _require.CramUnimplementedError,
    CramSizeLimitError = _require.CramSizeLimitError;

var CramFile = require('./cramFile');

var IndexedCramFile = function () {
  /**
   *
   * @param {object} args
   * @param {CramFile} args.cram
   * @param {Index-like} args.index object that supports getEntriesForRange(seqId,start,end) -> Promise[Array[index entries]]
   * @param {number} [args.cacheSize] optional maximum number of CRAM records to cache.  default 20,000
   * @param {number} [args.fetchSizeLimit] optional maximum number of bytes to fetch in a single getRecordsForRange call.  Default 3 MiB.
   * @param {boolean} [args.checkSequenceMD5] - default true. if false, disables verifying the MD5
   * checksum of the reference sequence underlying a slice. In some applications, this check can cause an inconvenient amount (many megabases) of sequences to be fetched.
   */
  function IndexedCramFile(args) {
    (0, _classCallCheck3.default)(this, IndexedCramFile);

    // { cram, index, seqFetch /* fasta, fastaIndex */ }) {
    if (args.cram) this.cram = args.cram;else this.cram = new CramFile({
      url: args.cramUrl,
      path: args.cramPath,
      filehandle: args.cramFilehandle,
      seqFetch: args.seqFetch,
      checkSequenceMD5: args.checkSequenceMD5,
      cacheSize: args.cacheSize
    });

    if (!(this.cram instanceof CramFile)) throw new Error('invalid arguments: no cramfile');

    this.index = args.index;
    if (!this.index.getEntriesForRange) throw new Error('invalid arguments: not an index');

    this.fetchSizeLimit = args.fetchSizeLimit || 3000000;
  }

  /**
   *
   * @param {number} seq numeric ID of the reference sequence
   * @param {number} start start of the range of interest. 1-based closed coordinates.
   * @param {number} end end of the range of interest. 1-based closed coordinates.
   * @returns {Promise[Array[CramRecord]]}
   */


  (0, _createClass3.default)(IndexedCramFile, [{
    key: 'getRecordsForRange',
    value: function () {
      var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(seq, start, end) {
        var _this = this,
            _Array$prototype;

        var seqId, slices, totalSize, filter, sliceResults;
        return _regenerator2.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(typeof seq === 'string')) {
                  _context.next = 2;
                  break;
                }

                throw new CramUnimplementedError('string sequence names not yet supported');

              case 2:
                seqId = seq;
                _context.next = 5;
                return this.index.getEntriesForRange(seqId, start, end);

              case 5:
                slices = _context.sent;
                totalSize = slices.map(function (s) {
                  return s.sliceBytes;
                }).reduce(function (a, b) {
                  return a + b;
                }, 0);

                if (!(totalSize > this.fetchSizeLimit)) {
                  _context.next = 9;
                  break;
                }

                throw new CramSizeLimitError('data size of ' + totalSize.toLocaleString() + ' bytes exceeded fetch size limit of ' + this.fetchSizeLimit.toLocaleString() + ' bytes');

              case 9:

                // TODO: do we need to merge or de-duplicate the blocks?

                // fetch all the slices and parse the feature data
                filter = function filter(feature) {
                  return feature.sequenceId === seq && feature.alignmentStart <= end && feature.alignmentStart + feature.lengthOnRef >= start;
                };

                _context.next = 12;
                return _promise2.default.all(slices.map(function (slice) {
                  return _this.getRecordsInSlice(slice, filter);
                }));

              case 12:
                sliceResults = _context.sent;
                return _context.abrupt('return', (_Array$prototype = Array.prototype).concat.apply(_Array$prototype, (0, _toConsumableArray3.default)(sliceResults)));

              case 14:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getRecordsForRange(_x, _x2, _x3) {
        return _ref.apply(this, arguments);
      }

      return getRecordsForRange;
    }()
  }, {
    key: 'getRecordsInSlice',
    value: function getRecordsInSlice(_ref2, filterFunction) {
      var containerStart = _ref2.containerStart,
          sliceStart = _ref2.sliceStart,
          sliceBytes = _ref2.sliceBytes;

      var container = this.cram.getContainerAtPosition(containerStart);
      var slice = container.getSlice(sliceStart, sliceBytes);
      return slice.getRecords(filterFunction);
    }

    /**
     *
     * @param {number} seqId
     * @returns {Promise} true if the CRAM file contains data for the given
     * reference sequence numerical ID
     */

  }, {
    key: 'hasDataForReferenceSequence',
    value: function hasDataForReferenceSequence(seqId) {
      return this.index.hasDataForReferenceSequence(seqId);
    }
  }]);
  return IndexedCramFile;
}();

module.exports = IndexedCramFile;