'use strict';

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var zlib = require('zlib');
var crc32 = require('buffer-crc32');
var LRU = require('lru-cache');

var _require = require('../errors'),
    CramUnimplementedError = _require.CramUnimplementedError,
    CramMalformedError = _require.CramMalformedError;

var rans = require('../rans');

var _require2 = require('./sectionParsers'),
    cramFileDefinitionParser = _require2.cramFileDefinition,
    _getSectionParsers = _require2.getSectionParsers;

var CramContainer = require('./container');

var _require3 = require('../io'),
    open = _require3.open;

var _require4 = require('./util'),
    parseItem = _require4.parseItem,
    tinyMemoize = _require4.tinyMemoize;

var _require5 = require('../sam'),
    parseHeaderText = _require5.parseHeaderText;

var CramFile = function () {
  /**
   * @param {object} args
   * @param {object} [args.filehandle] - a filehandle that implements the stat() and
   * read() methods of the Node filehandle API https://nodejs.org/api/fs.html#fs_class_filehandle
   * @param {object} [args.path] - path to the cram file
   * @param {object} [args.url] - url for the cram file.  also supports file:// urls for local files
   * @param {function} [args.seqFetch] - a function with signature
   * `(seqId, startCoordinate, endCoordinate)` that returns a promise for a string of sequence bases
   * @param {number} [args.cacheSize] optional maximum number of CRAM records to cache.  default 20,000
   * @param {boolean} [args.checkSequenceMD5] - default true. if false, disables verifying the MD5
   * checksum of the reference sequence underlying a slice. In some applications, this check can cause an inconvenient amount (many megabases) of sequences to be fetched.
   */
  function CramFile(args) {
    (0, _classCallCheck3.default)(this, CramFile);

    this.file = open(args.url, args.path, args.filehandle);
    this.validateChecksums = true;
    this.fetchReferenceSequenceCallback = args.seqFetch;
    this.options = {
      checkSequenceMD5: args.checkSequenceMD5 !== false,
      cacheSize: args.cacheSize !== undefined ? args.cacheSize : 20000

      // cache of features in a slice, keyed by the
      // slice offset. caches all of the features in a slice, or none.
      // the cache is actually used by the slice object, it's just
      // kept here at the level of the file
    };this.featureCache = LRU({
      max: this.options.cacheSize,
      length: function length(featureArray) {
        return featureArray.length;
      }
    });
  }

  (0, _createClass3.default)(CramFile, [{
    key: 'toString',
    value: function toString() {
      if (this.file.filename) return this.file.filename;
      if (this.file.url) return this.file.url;

      return '(cram file)';
    }

    // can just read this object like a filehandle

  }, {
    key: 'read',
    value: function read(buffer, offset, length, position) {
      return this.file.read(buffer, offset, length, position);
    }

    // can just stat this object like a filehandle

  }, {
    key: 'stat',
    value: function stat() {
      return this.file.stat();
    }

    // memoized

  }, {
    key: 'getDefinition',
    value: function () {
      var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
        var headbytes, definition;
        return _regenerator2.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                headbytes = Buffer.allocUnsafe(cramFileDefinitionParser.maxLength);
                _context.next = 3;
                return this.file.read(headbytes, 0, cramFileDefinitionParser.maxLength, 0);

              case 3:
                definition = cramFileDefinitionParser.parser.parse(headbytes).result;

                if (!(definition.majorVersion !== 2 && definition.majorVersion !== 3)) {
                  _context.next = 6;
                  break;
                }

                throw new CramUnimplementedError('CRAM version ' + definition.majorVersion + ' not supported');

              case 6:
                return _context.abrupt('return', definition);

              case 7:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getDefinition() {
        return _ref.apply(this, arguments);
      }

      return getDefinition;
    }()

    // memoize

  }, {
    key: 'getSamHeader',
    value: function () {
      var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2() {
        var firstContainer, _ref3, content, headerLength, textStart, text;

        return _regenerator2.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.getContainerById(0);

              case 2:
                firstContainer = _context2.sent;

                if (firstContainer) {
                  _context2.next = 5;
                  break;
                }

                throw new CramMalformedError('file contains no containers');

              case 5:
                _context2.next = 7;
                return firstContainer.getFirstBlock();

              case 7:
                _ref3 = _context2.sent;
                content = _ref3.content;

                // find the end of the trailing zeros in the header text
                headerLength = content.readInt32LE(0);
                textStart = 4;
                // let textEnd = content.length - 1
                // while (textEnd >= textStart && !content[textEnd]) textEnd -= 1
                // trim off the trailing zeros

                text = content.toString('utf8', textStart, textStart + headerLength);
                return _context2.abrupt('return', parseHeaderText(text));

              case 13:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getSamHeader() {
        return _ref2.apply(this, arguments);
      }

      return getSamHeader;
    }()

    // memoize

  }, {
    key: 'getSectionParsers',
    value: function () {
      var _ref4 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3() {
        var _ref5, majorVersion;

        return _regenerator2.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.getDefinition();

              case 2:
                _ref5 = _context3.sent;
                majorVersion = _ref5.majorVersion;
                return _context3.abrupt('return', _getSectionParsers(majorVersion));

              case 5:
              case 'end':
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getSectionParsers() {
        return _ref4.apply(this, arguments);
      }

      return getSectionParsers;
    }()
  }, {
    key: 'getContainerById',
    value: function () {
      var _ref6 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee4(containerNumber) {
        var sectionParsers, position, _ref7, fileSize, cramContainerHeader1, currentContainer, i, currentHeader, j, block;

        return _regenerator2.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.getSectionParsers();

              case 2:
                sectionParsers = _context4.sent;
                position = sectionParsers.cramFileDefinition.maxLength;
                _context4.next = 6;
                return this.file.stat();

              case 6:
                _ref7 = _context4.sent;
                fileSize = _ref7.size;
                cramContainerHeader1 = sectionParsers.cramContainerHeader1;

                // skip with a series of reads to the proper container

                currentContainer = void 0;
                i = 0;

              case 11:
                if (!(i <= containerNumber)) {
                  _context4.next = 37;
                  break;
                }

                if (!(position + cramContainerHeader1.maxLength + 8 >= fileSize)) {
                  _context4.next = 14;
                  break;
                }

                return _context4.abrupt('return', undefined);

              case 14:

                currentContainer = this.getContainerAtPosition(position);
                _context4.next = 17;
                return currentContainer.getHeader();

              case 17:
                currentHeader = _context4.sent;

                if (currentHeader) {
                  _context4.next = 20;
                  break;
                }

                throw new CramMalformedError('container ' + containerNumber + ' not found in file');

              case 20:
                if (!(i === 0)) {
                  _context4.next = 33;
                  break;
                }

                position = currentHeader._endPosition;
                j = 0;

              case 23:
                if (!(j < currentHeader.numBlocks)) {
                  _context4.next = 31;
                  break;
                }

                _context4.next = 26;
                return this.readBlock(position);

              case 26:
                block = _context4.sent;

                position = block._endPosition;

              case 28:
                j += 1;
                _context4.next = 23;
                break;

              case 31:
                _context4.next = 34;
                break;

              case 33:
                // otherwise, just traverse to the next container using the container's length
                position += currentHeader._size + currentHeader.length;

              case 34:
                i += 1;
                _context4.next = 11;
                break;

              case 37:
                return _context4.abrupt('return', currentContainer);

              case 38:
              case 'end':
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getContainerById(_x) {
        return _ref6.apply(this, arguments);
      }

      return getContainerById;
    }()
  }, {
    key: 'checkCrc32',
    value: function () {
      var _ref8 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee5(position, length, recordedCrc32, description) {
        var b, calculatedCrc32;
        return _regenerator2.default.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                b = Buffer.allocUnsafe(length);
                _context5.next = 3;
                return this.file.read(b, 0, length, position);

              case 3:
                calculatedCrc32 = crc32.unsigned(b);

                if (!(calculatedCrc32 !== recordedCrc32)) {
                  _context5.next = 6;
                  break;
                }

                throw new CramMalformedError('crc mismatch in ' + description + ': recorded CRC32 = ' + recordedCrc32 + ', but calculated CRC32 = ' + calculatedCrc32);

              case 6:
              case 'end':
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function checkCrc32(_x2, _x3, _x4, _x5) {
        return _ref8.apply(this, arguments);
      }

      return checkCrc32;
    }()

    /**
     * @returns {Promise[number]} the number of containers in the file
     */

  }, {
    key: 'containerCount',
    value: function () {
      var _ref9 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee6() {
        var sectionParsers, _ref10, fileSize, cramContainerHeader1, containerCount, position, currentHeader, j, block;

        return _regenerator2.default.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this.getSectionParsers();

              case 2:
                sectionParsers = _context6.sent;
                _context6.next = 5;
                return this.file.stat();

              case 5:
                _ref10 = _context6.sent;
                fileSize = _ref10.size;
                cramContainerHeader1 = sectionParsers.cramContainerHeader1;
                containerCount = 0;
                position = sectionParsers.cramFileDefinition.maxLength;

              case 10:
                if (!(position + cramContainerHeader1.maxLength + 8 < fileSize)) {
                  _context6.next = 33;
                  break;
                }

                _context6.next = 13;
                return this.getContainerAtPosition(position).getHeader();

              case 13:
                currentHeader = _context6.sent;

                if (currentHeader) {
                  _context6.next = 16;
                  break;
                }

                return _context6.abrupt('break', 33);

              case 16:
                if (!(containerCount === 0)) {
                  _context6.next = 29;
                  break;
                }

                position = currentHeader._endPosition;
                j = 0;

              case 19:
                if (!(j < currentHeader.numBlocks)) {
                  _context6.next = 27;
                  break;
                }

                _context6.next = 22;
                return this.readBlock(position);

              case 22:
                block = _context6.sent;

                position = block._endPosition;

              case 24:
                j += 1;
                _context6.next = 19;
                break;

              case 27:
                _context6.next = 30;
                break;

              case 29:
                // otherwise, just traverse to the next container using the container's length
                position += currentHeader._size + currentHeader.length;

              case 30:
                containerCount += 1;
                _context6.next = 10;
                break;

              case 33:
                return _context6.abrupt('return', containerCount);

              case 34:
              case 'end':
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function containerCount() {
        return _ref9.apply(this, arguments);
      }

      return containerCount;
    }()
  }, {
    key: 'getContainerAtPosition',
    value: function getContainerAtPosition(position) {
      return new CramContainer(this, position);
    }
  }, {
    key: 'readBlockHeader',
    value: function () {
      var _ref11 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee7(position) {
        var sectionParsers, cramBlockHeader, _ref12, fileSize, buffer;

        return _regenerator2.default.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this.getSectionParsers();

              case 2:
                sectionParsers = _context7.sent;
                cramBlockHeader = sectionParsers.cramBlockHeader;
                _context7.next = 6;
                return this.file.stat();

              case 6:
                _ref12 = _context7.sent;
                fileSize = _ref12.size;

                if (!(position + cramBlockHeader.maxLength >= fileSize)) {
                  _context7.next = 10;
                  break;
                }

                return _context7.abrupt('return', undefined);

              case 10:
                buffer = Buffer.allocUnsafe(cramBlockHeader.maxLength);
                _context7.next = 13;
                return this.file.read(buffer, 0, cramBlockHeader.maxLength, position);

              case 13:
                return _context7.abrupt('return', parseItem(buffer, cramBlockHeader.parser, 0, position));

              case 14:
              case 'end':
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function readBlockHeader(_x6) {
        return _ref11.apply(this, arguments);
      }

      return readBlockHeader;
    }()
  }, {
    key: '_parseSection',
    value: function () {
      var _ref13 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee8(section, position) {
        var size = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : section.maxLength;
        var preReadBuffer = arguments[3];

        var buffer, _ref14, fileSize, data;

        return _regenerator2.default.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                buffer = void 0;

                if (!preReadBuffer) {
                  _context8.next = 5;
                  break;
                }

                buffer = preReadBuffer;
                _context8.next = 14;
                break;

              case 5:
                _context8.next = 7;
                return this.file.stat();

              case 7:
                _ref14 = _context8.sent;
                fileSize = _ref14.size;

                if (!(position + size >= fileSize)) {
                  _context8.next = 11;
                  break;
                }

                return _context8.abrupt('return', undefined);

              case 11:
                buffer = Buffer.allocUnsafe(size);
                _context8.next = 14;
                return this.file.read(buffer, 0, size, position);

              case 14:
                data = parseItem(buffer, section.parser, 0, position);

                if (!(data._size !== size)) {
                  _context8.next = 17;
                  break;
                }

                throw new CramMalformedError('section read error: requested size ' + size + ' does not equal parsed size ' + data._size);

              case 17:
                return _context8.abrupt('return', data);

              case 18:
              case 'end':
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function _parseSection(_x7, _x8) {
        return _ref13.apply(this, arguments);
      }

      return _parseSection;
    }()
  }, {
    key: '_uncompress',
    value: function _uncompress(compressionMethod, inputBuffer, outputBuffer) {
      if (compressionMethod === 'gzip') {
        var result = zlib.gunzipSync(inputBuffer);
        result.copy(outputBuffer);
      } else if (compressionMethod === 'rans') {
        rans.uncompress(inputBuffer, outputBuffer);
      } else {
        throw new CramUnimplementedError(compressionMethod + ' decompression not yet implemented');
      }
    }
  }, {
    key: 'readBlock',
    value: function () {
      var _ref15 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee9(position) {
        var _ref16, majorVersion, sectionParsers, block, blockContentPosition, uncompressedData, compressedData, crc;

        return _regenerator2.default.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return this.getDefinition();

              case 2:
                _ref16 = _context9.sent;
                majorVersion = _ref16.majorVersion;
                _context9.next = 6;
                return this.getSectionParsers();

              case 6:
                sectionParsers = _context9.sent;
                _context9.next = 9;
                return this.readBlockHeader(position);

              case 9:
                block = _context9.sent;
                blockContentPosition = block._endPosition;

                block.contentPosition = block._endPosition;

                uncompressedData = Buffer.allocUnsafe(block.uncompressedSize);

                if (!(block.compressionMethod !== 'raw')) {
                  _context9.next = 20;
                  break;
                }

                compressedData = Buffer.allocUnsafe(block.compressedSize);
                _context9.next = 17;
                return this.read(compressedData, 0, block.compressedSize, blockContentPosition);

              case 17:

                this._uncompress(block.compressionMethod, compressedData, uncompressedData);
                _context9.next = 22;
                break;

              case 20:
                _context9.next = 22;
                return this.read(uncompressedData, 0, block.uncompressedSize, blockContentPosition);

              case 22:

                block.content = uncompressedData;

                if (!(majorVersion >= 3)) {
                  _context9.next = 35;
                  break;
                }

                _context9.next = 26;
                return this._parseSection(sectionParsers.cramBlockCrc32, blockContentPosition + block.compressedSize);

              case 26:
                crc = _context9.sent;

                block.crc32 = crc.crc32;

                // check the block data crc32

                if (!this.validateChecksums) {
                  _context9.next = 31;
                  break;
                }

                _context9.next = 31;
                return this.checkCrc32(position, block._size + block.compressedSize, block.crc32, 'block data');

              case 31:

                // make the endposition and size reflect the whole block
                block._endPosition = crc._endPosition;
                block._size = block.compressedSize + sectionParsers.cramBlockCrc32.maxLength;
                _context9.next = 37;
                break;

              case 35:
                block._endPosition = blockContentPosition + block.compressedSize;
                block._size = block.compressedSize;

              case 37:
                return _context9.abrupt('return', block);

              case 38:
              case 'end':
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function readBlock(_x10) {
        return _ref15.apply(this, arguments);
      }

      return readBlock;
    }()
  }]);
  return CramFile;
}();

'getDefinition getSectionParsers getSamHeader'.split(' ').forEach(function (method) {
  return tinyMemoize(CramFile, method);
});

module.exports = CramFile;