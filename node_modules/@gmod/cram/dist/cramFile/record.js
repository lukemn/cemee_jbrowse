'use strict';

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Constants = require('./constants');

function decodeReadSequence(cramRecord, refRegion) {
  // if it has no length, it has no sequence
  if (!cramRecord.lengthOnRef && !cramRecord.readLength) return undefined;

  if (cramRecord.isUnknownBases()) return undefined;

  // remember: all coordinates are 1-based closed
  var regionSeqOffset = cramRecord.alignmentStart - refRegion.start;

  if (!cramRecord.readFeatures) return refRegion.seq.substr(regionSeqOffset, cramRecord.lengthOnRef).toUpperCase();

  var bases = '';
  var regionPos = regionSeqOffset;
  var currentReadFeature = 0;
  while (bases.length < cramRecord.readLength) {
    if (currentReadFeature < cramRecord.readFeatures.length && cramRecord.readFeatures[currentReadFeature].pos === bases.length + 1) {
      // process the read feature
      var feature = cramRecord.readFeatures[currentReadFeature];
      currentReadFeature += 1;
      if (feature.code === 'b') {
        // specify a base pair for some reason
        bases += feature.data;
        regionPos += 1;
      } else if (feature.code === 'B') {
        // base pair and associated quality
        // TODO: do we need to set the quality in the qual scores?
        bases += feature.data[0];
        regionPos += 1;
      } else if (feature.code === 'X') {
        // base substitution
        bases += feature.sub;
        regionPos += 1;
      } else if (feature.code === 'I') {
        // insertion
        bases += feature.data;
      } else if (feature.code === 'D') {
        // deletion
        regionPos += feature.data;
      } else if (feature.code === 'i') {
        // insert single base
        bases += feature.data;
      } else if (feature.code === 'N') {
        // reference skip. delete some bases
        // do nothing
        // seqBases.splice(feature.pos - 1, feature.data)
        regionPos += feature.data;
      } else if (feature.code === 'S') {
        // soft clipped bases that should be present in the read seq
        // seqBases.splice(feature.pos - 1, 0, ...feature.data.split(''))
        bases += feature.data;
      } else if (feature.code === 'P') {
        // padding, do nothing
      } else if (feature.code === 'H') {
        // hard clip, do nothing
      }
    } else if (currentReadFeature < cramRecord.readFeatures.length) {
      // put down a chunk of sequence up to the next read feature
      var chunk = refRegion.seq.substr(regionPos, cramRecord.readFeatures[currentReadFeature].pos - bases.length - 1);
      bases += chunk;
      regionPos += chunk.length;
    } else {
      // put down a chunk of reference up to the full read length
      var _chunk = refRegion.seq.substr(regionPos, cramRecord.readLength - bases.length);
      bases += _chunk;
      regionPos += _chunk.length;
    }
  }

  return bases.toUpperCase();
}

var baseNumbers = {
  a: 0,
  A: 0,
  c: 1,
  C: 1,
  g: 2,
  G: 2,
  t: 3,
  T: 3,
  n: 4,
  N: 4
};

function decodeBaseSubstitution(cramRecord, refRegion, compressionScheme, readFeature) {
  if (!refRegion) return;

  // decode base substitution code using the substitution matrix
  var refCoord = readFeature.refPos - refRegion.start;
  var refBase = refRegion.seq.charAt(refCoord);
  if (refBase) readFeature.ref = refBase;
  var baseNumber = baseNumbers[refBase];
  if (baseNumber === undefined) baseNumber = 4;
  var substitutionScheme = compressionScheme.substitutionMatrix[baseNumber];
  var base = substitutionScheme[readFeature.data];
  if (base) readFeature.sub = base;
}

/**
 * Class of each CRAM record returned by this API.
 */

var CramRecord = function () {
  function CramRecord() {
    (0, _classCallCheck3.default)(this, CramRecord);

    this.tags = {};
  }

  /**
   * @returns {boolean} true if the read is paired, regardless of whether both segments are mapped
   */


  (0, _createClass3.default)(CramRecord, [{
    key: 'isPaired',
    value: function isPaired() {
      return !!(this.flags & Constants.BAM_FPAIRED);
    }

    /** @returns {boolean} true if the read is paired, and both segments are mapped */

  }, {
    key: 'isProperlyPaired',
    value: function isProperlyPaired() {
      return !!(this.flags & Constants.BAM_FPROPER_PAIR);
    }

    /** @returns {boolean} true if the read itself is unmapped; conflictive with isProperlyPaired */

  }, {
    key: 'isSegmentUnmapped',
    value: function isSegmentUnmapped() {
      return !!(this.flags & Constants.BAM_FUNMAP);
    }

    /** @returns {boolean} true if the read itself is unmapped; conflictive with isProperlyPaired */

  }, {
    key: 'isMateUnmapped',
    value: function isMateUnmapped() {
      return !!(this.flags & Constants.BAM_FMUNMAP);
    }

    /** @returns {boolean} true if the read is mapped to the reverse strand */

  }, {
    key: 'isReverseComplemented',
    value: function isReverseComplemented() {
      return !!(this.flags & Constants.BAM_FREVERSE);
    }

    /** @returns {boolean} true if the mate is mapped to the reverse strand */

  }, {
    key: 'isMateReverseComplemented',
    value: function isMateReverseComplemented() {
      return !!(this.flags & Constants.BAM_FMREVERSE);
    }

    /** @returns {boolean} true if this is read number 1 in a pair */

  }, {
    key: 'isRead1',
    value: function isRead1() {
      return !!(this.flags & Constants.BAM_FREAD1);
    }

    /** @returns {boolean} true if this is read number 2 in a pair */

  }, {
    key: 'isRead2',
    value: function isRead2() {
      return !!(this.flags & Constants.BAM_FREAD2);
    }

    /** @returns {boolean} true if this is a secondary alignment */

  }, {
    key: 'isSecondary',
    value: function isSecondary() {
      return !!(this.flags & Constants.BAM_FSECONDARY);
    }

    /** @returns {boolean} true if this read has failed QC checks */

  }, {
    key: 'isFailedQc',
    value: function isFailedQc() {
      return !!(this.flags & Constants.BAM_FQCFAIL);
    }

    /** @returns {boolean} true if the read is an optical or PCR duplicate */

  }, {
    key: 'isDuplicate',
    value: function isDuplicate() {
      return !!(this.flags & Constants.BAM_FDUP);
    }

    /** @returns {boolean} true if this is a supplementary alignment */

  }, {
    key: 'isSupplementary',
    value: function isSupplementary() {
      return !!(this.flags & Constants.BAM_FSUPPLEMENTARY);
    }

    /**
     * @returns {boolean} true if the read is detached
     */

  }, {
    key: 'isDetached',
    value: function isDetached() {
      return !!(this.cramFlags & Constants.CRAM_FLAG_DETACHED);
    }

    /** @returns {boolean} true if the read has a mate in this same CRAM segment */

  }, {
    key: 'hasMateDownStream',
    value: function hasMateDownStream() {
      return !!(this.cramFlags & Constants.CRAM_FLAG_MATE_DOWNSTREAM);
    }

    /** @returns {boolean} true if the read contains qual scores */

  }, {
    key: 'isPreservingQualityScores',
    value: function isPreservingQualityScores() {
      return !!(this.cramFlags & Constants.CRAM_FLAG_PRESERVE_QUAL_SCORES);
    }

    /** @returns {boolean} true if the read has no sequence bases */

  }, {
    key: 'isUnknownBases',
    value: function isUnknownBases() {
      return !!(this.cramFlags & Constants.CRAM_FLAG_NO_SEQ);
    }

    /**
     * Get the original sequence of this read.
     * @returns {String} sequence basepairs
     */

  }, {
    key: 'getReadBases',
    value: function getReadBases() {
      if (!this.readBases && this._refRegion) {
        this.readBases = decodeReadSequence(this, this._refRegion);
      }
      return this.readBases;
    }

    /**
     * Annotates this feature with the given reference sequence basepair
     * information. This will add a `sub` and a `ref` item to base
     * subsitution read features given the actual substituted and reference
     * base pairs, and will make the `getReadSequence()` method work.
     *
     * @param {object} refRegion
     * @param {number} refRegion.start
     * @param {number} refRegion.end
     * @param {string} refRegion.seq
     * @param {CramContainerCompressionScheme} compressionScheme
     * @returns {undefined} nothing
     */

  }, {
    key: 'addReferenceSequence',
    value: function addReferenceSequence(refRegion, compressionScheme) {
      var _this = this;

      if (this.readFeatures) {
        // use the reference bases to decode the bases
        // substituted in each base substitution
        this.readFeatures.forEach(function (readFeature) {
          if (readFeature.code === 'X') decodeBaseSubstitution(_this, refRegion, compressionScheme, readFeature);
        });
      }

      // if this region completely covers this read,
      // keep a reference to it
      if (!this.readBases && refRegion.start <= this.alignmentStart && refRegion.end >= this.alignmentStart + (this.lengthOnRef || this.readLength) - 1) {
        this._refRegion = refRegion;
      }
    }
  }, {
    key: 'toJSON',
    value: function toJSON() {
      var _this2 = this;

      var data = {};
      (0, _keys2.default)(this).forEach(function (k) {
        if (k.charAt(0) === '_') return;
        data[k] = _this2[k];
      });

      data.readBases = this.getReadBases();

      return data;
    }
  }]);
  return CramRecord;
}();

module.exports = CramRecord;