'use strict';

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _values = require('babel-runtime/core-js/object/values');

var _values2 = _interopRequireDefault(_values);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _entries = require('babel-runtime/core-js/object/entries');

var _entries2 = _interopRequireDefault(_entries);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _require = require('../../errors'),
    CramMalformedError = _require.CramMalformedError;

var CramCodec = require('./_base');

function numberOfSetBits(ii) {
  var i = ii - (ii >> 1) & 0x55555555;
  i = (i & 0x33333333) + (i >> 2 & 0x33333333);
  return (i + (i >> 4) & 0x0f0f0f0f) * 0x01010101 >> 24;
}

var HuffmanIntCodec = function (_CramCodec) {
  (0, _inherits3.default)(HuffmanIntCodec, _CramCodec);

  function HuffmanIntCodec() {
    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var dataType = arguments[1];
    (0, _classCallCheck3.default)(this, HuffmanIntCodec);

    var _this = (0, _possibleConstructorReturn3.default)(this, (HuffmanIntCodec.__proto__ || (0, _getPrototypeOf2.default)(HuffmanIntCodec)).call(this, parameters, dataType));

    if (!['byte', 'int'].includes(_this.dataType)) {
      throw new TypeError(_this.dataType + ' decoding not yet implemented by HUFFMAN_INT codec');
    }

    _this.buildCodeBook();
    _this.buildCodes();
    _this.buildCaches();

    // if this is a degenerate zero-length huffman code, special-case the decoding
    if (_this.sortedCodes[0].bitLength === 0) _this._decode = _this._decodeZeroLengthCode;
    return _this;
  }

  (0, _createClass3.default)(HuffmanIntCodec, [{
    key: 'buildCodeBook',
    value: function buildCodeBook() {
      var _this2 = this;

      // parse the parameters together into a `codes` data structure
      var codes = new Array(this.parameters.numCodes);
      for (var i = 0; i < this.parameters.numCodes; i += 1) {
        codes[i] = {
          symbol: this.parameters.symbols[i],
          bitLength: this.parameters.bitLengths[i]
        };
      }
      // sort the codes by bit length and symbol value
      codes = codes.sort(function (a, b) {
        return a.bitLength - b.bitLength || a.symbol - b.symbol;
      });

      this.codeBook = {};
      codes.forEach(function (code) {
        if (!_this2.codeBook[code.bitLength]) _this2.codeBook[code.bitLength] = [];
        _this2.codeBook[code.bitLength].push(code.symbol);
      });
    }
  }, {
    key: 'buildCodes',
    value: function buildCodes() {
      var _this3 = this;

      this.codes = {}; /*  new TreeMap<Integer, HuffmanBitCode>(); */
      var codeLength = 0;
      var codeValue = -1;
      (0, _entries2.default)(this.codeBook).forEach(function (_ref) {
        var _ref2 = (0, _slicedToArray3.default)(_ref, 2),
            bitLength = _ref2[0],
            symbols = _ref2[1];

        bitLength = parseInt(bitLength, 10);
        symbols.forEach(function (symbol) {
          var code = { bitLength: bitLength, value: symbol };
          codeValue += 1;
          var delta = bitLength - codeLength; // new length?
          codeValue <<= delta; // pad with 0's
          code.bitCode = codeValue; // calculated: huffman code
          codeLength += delta; // adjust current code length

          if (numberOfSetBits(codeValue) > bitLength) throw new CramMalformedError('Symbol out of range');

          _this3.codes[symbol] = code;
        });
      });
    }
  }, {
    key: 'buildCaches',
    value: function buildCaches() {
      this.sortedCodes = (0, _values2.default)(this.codes).sort(function (a, b) {
        return a.bitLength - b.bitLength || a.bitCode - b.bitCode;
      });

      // this.sortedValues = this.parameters.values.sort((a,b) => a-b)
      this.sortedByValue = (0, _values2.default)(this.codes).sort(function (a, b) {
        return a.value - b.value;
      });

      this.sortedValuesByBitCode = this.sortedCodes.map(function (c) {
        return c.value;
      });
      this.sortedBitCodes = this.sortedCodes.map(function (c) {
        return c.bitCode;
      });
      this.sortedBitLengthsByBitCode = this.sortedCodes.map(function (c) {
        return c.bitLength;
      });
      var maxBitCode = Math.max.apply(Math, (0, _toConsumableArray3.default)(this.sortedBitCodes));

      this.bitCodeToValue = new Array(maxBitCode + 1).fill(-1);
      for (var i = 0; i < this.sortedBitCodes.length; i += 1) {
        this.bitCodeToValue[this.sortedCodes[i].bitCode] = i;
      }
    }
  }, {
    key: 'decode',
    value: function decode(slice, coreDataBlock, blocksByContentId, cursors) {
      return this._decode(slice, coreDataBlock, cursors.coreBlock);
    }

    // _decodeNull() {
    //   return -1
    // }

    // the special case for zero-length codes

  }, {
    key: '_decodeZeroLengthCode',
    value: function _decodeZeroLengthCode() {
      return this.sortedCodes[0].value;
    }
  }, {
    key: '_decode',
    value: function _decode(slice, coreDataBlock, coreCursor) {
      var input = coreDataBlock.content;

      var prevLen = 0;
      var bits = 0;
      for (var i = 0; i < this.sortedCodes.length; i += 1) {
        var length = this.sortedCodes[i].bitLength;
        bits <<= length - prevLen;
        bits |= this._getBits(input, coreCursor, length - prevLen);
        prevLen = length;
        {
          var index = this.bitCodeToValue[bits];
          if (index > -1 && this.sortedBitLengthsByBitCode[index] === length) return this.sortedValuesByBitCode[index];

          for (var j = i; this.sortedCodes[j + 1].bitLength === length && j < this.sortedCodes.length; j += 1) {
            i += 1;
          }
        }
      }
      throw new CramMalformedError('Huffman symbol not found.');
    }
  }]);
  return HuffmanIntCodec;
}(CramCodec);

module.exports = HuffmanIntCodec;