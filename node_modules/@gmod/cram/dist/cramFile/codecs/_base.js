'use strict';

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _require = require('../../errors'),
    CramBufferOverrunError = _require.CramBufferOverrunError;

var validDataTypes = {
  int: true,
  byte: true,
  long: true,
  byteArray: true,
  byteArrayBlock: true

  // codec base class
};
var CramCodec = function () {
  function CramCodec() {
    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var dataType = arguments[1];
    (0, _classCallCheck3.default)(this, CramCodec);

    this.parameters = parameters;
    this.dataType = dataType;
    if (!dataType) throw new TypeError('must provide a data type to codec constructor');
    if (!validDataTypes[dataType]) throw new TypeError('invalid data type ' + dataType);
  }

  // decode(slice, coreDataBlock, blocksByContentId, cursors) {
  // }

  (0, _createClass3.default)(CramCodec, [{
    key: '_getBits',
    value: function _getBits(data, cursor, numBits) {
      var val = 0;
      if (cursor.bytePosition + (7 - cursor.bitPosition + numBits) / 8 > data.length) throw new CramBufferOverrunError('read error during decoding. the file seems to be truncated.');
      for (var dlen = numBits; dlen; dlen -= 1) {
        // get the next `dlen` bits in the input, put them in val
        val <<= 1;
        val |= data[cursor.bytePosition] >> cursor.bitPosition & 1;
        cursor.bitPosition -= 1;
        if (cursor.bitPosition < 0) cursor.bytePosition += 1;
        cursor.bitPosition &= 7;
      }
      return val;
    }
  }]);
  return CramCodec;
}();

module.exports = CramCodec;