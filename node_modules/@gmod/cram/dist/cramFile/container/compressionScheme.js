'use strict';

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _require = require('../../errors'),
    CramMalformedError = _require.CramMalformedError;

var _require2 = require('../codecs'),
    instantiateCodec = _require2.instantiateCodec;

// the hardcoded data type to be decoded for each core
// data field


var dataSeriesTypes = {
  BF: 'int',
  CF: 'int',
  RI: 'int',
  RL: 'int',
  AP: 'int',
  RG: 'int',
  MF: 'int',
  NS: 'int',
  NP: 'int',
  TS: 'int',
  NF: 'int',
  TC: 'byte',
  TN: 'int',
  FN: 'int',
  FC: 'byte',
  FP: 'int',
  BS: 'byte',
  IN: 'byteArray',
  SC: 'byteArray',
  DL: 'int',
  BA: 'byte',
  BB: 'byteArray',
  RS: 'int',
  PD: 'int',
  HC: 'int',
  MQ: 'int',
  RN: 'byteArray',
  QS: 'byte',
  QQ: 'byteArray',
  TL: 'int',
  TM: 'ignore',
  TV: 'ignore'
};

function parseSubstitutionMatrix(byteArray) {
  var matrix = new Array(5);
  for (var i = 0; i < 5; i += 1) {
    matrix[i] = new Array(4);
  }matrix[0][byteArray[0] >> 6 & 3] = 'C';
  matrix[0][byteArray[0] >> 4 & 3] = 'G';
  matrix[0][byteArray[0] >> 2 & 3] = 'T';
  matrix[0][byteArray[0] >> 0 & 3] = 'N';

  matrix[1][byteArray[1] >> 6 & 3] = 'A';
  matrix[1][byteArray[1] >> 4 & 3] = 'G';
  matrix[1][byteArray[1] >> 2 & 3] = 'T';
  matrix[1][byteArray[1] >> 0 & 3] = 'N';

  matrix[2][byteArray[2] >> 6 & 3] = 'A';
  matrix[2][byteArray[2] >> 4 & 3] = 'C';
  matrix[2][byteArray[2] >> 2 & 3] = 'T';
  matrix[2][byteArray[2] >> 0 & 3] = 'N';

  matrix[3][byteArray[3] >> 6 & 3] = 'A';
  matrix[3][byteArray[3] >> 4 & 3] = 'C';
  matrix[3][byteArray[3] >> 2 & 3] = 'G';
  matrix[3][byteArray[3] >> 0 & 3] = 'N';

  matrix[4][byteArray[4] >> 6 & 3] = 'A';
  matrix[4][byteArray[4] >> 4 & 3] = 'C';
  matrix[4][byteArray[4] >> 2 & 3] = 'G';
  matrix[4][byteArray[4] >> 0 & 3] = 'T';

  return matrix;
}

var CramContainerCompressionScheme = function () {
  function CramContainerCompressionScheme(content) {
    (0, _classCallCheck3.default)(this, CramContainerCompressionScheme);

    (0, _assign2.default)(this, content);
    // interpret some of the preservation map tags for convenient use
    this.readNamesIncluded = content.preservation.RN;
    this.APdelta = content.preservation.AP;
    this.referenceRequired = !!content.preservation.RR;
    this.tagIdsDictionary = content.preservation.TD;
    this.substitutionMatrix = parseSubstitutionMatrix(content.preservation.SM);

    this.dataSeriesCodecCache = {};
    this.tagCodecCache = {};
  }

  /**
   * @param {string} tagName three-character tag name
   * @private
   */


  (0, _createClass3.default)(CramContainerCompressionScheme, [{
    key: 'getCodecForTag',
    value: function getCodecForTag(tagName) {
      if (!this.tagCodecCache[tagName]) {
        var encodingData = this.tagEncoding[tagName];
        if (encodingData) {
          this.tagCodecCache[tagName] = instantiateCodec(encodingData, 'byteArray' // all tags are byte array data
          );
        }
      }
      return this.tagCodecCache[tagName];
    }

    /**
     *
     * @param {number} tagListId ID of the tag list to fetch from the tag dictionary
     * @private
     */

  }, {
    key: 'getTagNames',
    value: function getTagNames(tagListId) {
      return this.tagIdsDictionary[tagListId];
    }
  }, {
    key: 'getCodecForDataSeries',
    value: function getCodecForDataSeries(dataSeriesName) {
      if (!this.dataSeriesCodecCache[dataSeriesName]) {
        var encodingData = this.dataSeriesEncoding[dataSeriesName];
        if (encodingData) {
          var dataType = dataSeriesTypes[dataSeriesName];
          if (!dataType) throw new CramMalformedError('data series name ' + dataSeriesName + ' not defined in file compression header');
          this.dataSeriesCodecCache[dataSeriesName] = instantiateCodec(encodingData, dataType);
        }
      }
      return this.dataSeriesCodecCache[dataSeriesName];
    }
  }, {
    key: 'toJSON',
    value: function toJSON() {
      var _this = this;

      var data = {};
      (0, _keys2.default)(this).forEach(function (k) {
        if (/Cache$/.test(k)) return;
        data[k] = _this[k];
      });
      return data;
    }
  }]);
  return CramContainerCompressionScheme;
}();

module.exports = CramContainerCompressionScheme;