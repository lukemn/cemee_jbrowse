'use strict';

var _isNan = require('babel-runtime/core-js/number/is-nan');

var _isNan2 = _interopRequireDefault(_isNan);

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _parseInt = require('babel-runtime/core-js/number/parse-int');

var _parseInt2 = _interopRequireDefault(_parseInt);

var _minSafeInteger = require('babel-runtime/core-js/number/min-safe-integer');

var _minSafeInteger2 = _interopRequireDefault(_minSafeInteger);

var _maxSafeInteger = require('babel-runtime/core-js/number/max-safe-integer');

var _maxSafeInteger2 = _interopRequireDefault(_maxSafeInteger);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _require = require('../../errors'),
    CramMalformedError = _require.CramMalformedError,
    CramUnimplementedError = _require.CramUnimplementedError;

var Long = require('long');

var CramRecord = require('../record');

/**
 * given a Buffer, read a string up to the first null character
 * @private
 */
function readNullTerminatedStringFromBuffer(buffer) {
  var zeroOffset = buffer.indexOf(0);
  if (zeroOffset === -1) return buffer.toString('utf8');
  return buffer.toString('utf8', 0, zeroOffset);
}

/**
 * parse a BAM tag's array value from a binary buffer
 * @private
 */
function parseTagValueArray(buffer) {
  var arrayType = String.fromCharCode(buffer[0]);
  var length = buffer.readInt32LE(1);

  var schema = {
    c: ['readInt8', 1],
    C: ['readUInt8', 1],
    s: ['readInt16LE', 2],
    S: ['readUInt16LE', 2],
    i: ['readInt32LE', 4],
    I: ['readUInt32LE', 4],
    f: ['readFloatLE', 4]
  }[arrayType];
  if (!schema) throw new CramMalformedError('invalid tag value array type \'' + arrayType + '\'');

  var _schema = (0, _slicedToArray3.default)(schema, 2),
      getMethod = _schema[0],
      itemSize = _schema[1];

  var array = new Array(length);
  var offset = 5;
  for (var i = 0; i < length; i += 1) {
    array[i] = buffer[getMethod](offset);
    offset += itemSize;
  }
  return array;
}

function parseTagData(tagType, buffer) {
  if (!buffer.readInt32LE) buffer = Buffer.from(buffer);
  if (tagType === 'Z') return readNullTerminatedStringFromBuffer(buffer);else if (tagType === 'A') return String.fromCharCode(buffer[0]);else if (tagType === 'I') {
    var val = Long.fromBytesLE(buffer);
    if (val.greaterThan(_maxSafeInteger2.default) || val.lessThan(_minSafeInteger2.default)) throw new CramUnimplementedError('integer overflow');
    return val.toNumber();
  } else if (tagType === 'i') return buffer.readInt32LE(0);else if (tagType === 's') return buffer.readInt16LE(0);else if (tagType === 'S') return buffer.readUInt16LE(0);else if (tagType === 'c') return buffer.readInt8(0);else if (tagType === 'C') return buffer.readUInt8(0);else if (tagType === 'f') return buffer.readFloatLE(0);
  if (tagType === 'H') {
    var hex = readNullTerminatedStringFromBuffer(buffer);
    return (0, _parseInt2.default)(hex.replace(/^0x/, ''), 16);
  }
  if (tagType === 'B') return parseTagValueArray(buffer);

  throw new CramMalformedError('Unrecognized tag type ' + tagType);
}

function decodeReadFeatures(cramRecord, readFeatureCount, decodeDataSeries, compressionScheme, majorVersion) {
  var currentReadPos = 0;
  var currentRefPos = cramRecord.alignmentStart - 1;
  var readFeatures = new Array(readFeatureCount);

  function decodeRFData(_ref) {
    var _ref2 = (0, _slicedToArray3.default)(_ref, 2),
        type = _ref2[0],
        dataSeriesName = _ref2[1];

    var data = decodeDataSeries(dataSeriesName);
    if (type === 'character') {
      return String.fromCharCode(data);
    } else if (type === 'string') {
      return data.toString('utf8');
    } else if (type === 'numArray') {
      return data.toArray();
    }
    // else if (type === 'number') {
    //   return data[0]
    // }
    return data;
  }

  for (var i = 0; i < readFeatureCount; i += 1) {
    var code = String.fromCharCode(decodeDataSeries('FC'));

    var readPosDelta = decodeDataSeries('FP');

    var readFeature = { code: code
      // map of operator name -> data series name
    };var data1Schema = {
      B: ['character', 'BA'],
      S: ['string', majorVersion > 1 ? 'SC' : 'IN'], // IN if cram v1, SC otherwise
      X: ['number', 'BS'],
      D: ['number', 'DL'],
      I: ['string', 'IN'],
      i: ['character', 'BA'],
      b: ['string', 'BB'],
      q: ['numArray', 'QQ'],
      Q: ['number', 'QS'],
      H: ['number', 'HC'],
      P: ['number', 'PD'],
      N: ['number', 'RS']
    }[code];

    if (!data1Schema) throw new CramMalformedError('invalid read feature code "' + code + '"');

    readFeature.data = decodeRFData(data1Schema);

    // if this is a tag with two data items, make the data an array and add the second item
    var data2Schema = { B: ['number', 'QS'] }[code];
    if (data2Schema) readFeature.data = [readFeature.data, decodeRFData(data2Schema)];

    currentReadPos += readPosDelta;
    readFeature.pos = currentReadPos;

    currentRefPos += readPosDelta;
    readFeature.refPos = currentRefPos;

    // for gapping features, adjust the reference position for read features that follow
    if (code === 'D' || code === 'N') currentRefPos += readFeature.data;else if (code === 'H') currentRefPos -= readFeature.data;else if (code === 'I' || code === 'S') currentRefPos -= readFeature.data.length;else if (code === 'i') currentRefPos -= 1;

    readFeatures[i] = readFeature;
  }
  return readFeatures;
}

function thingToString(thing) {
  if (thing instanceof Buffer) {
    return readNullTerminatedStringFromBuffer(thing);
  } else if (thing.length && thing.indexOf) {
    // array-like
    if (!thing[thing.length - 1]) {
      // trim zeroes off the end if necessary
      var termIndex = thing.indexOf(0);
      return String.fromCharCode.apply(String, (0, _toConsumableArray3.default)(thing.slice(0, termIndex)));
    }
    return String.fromCharCode.apply(String, (0, _toConsumableArray3.default)(thing));
  }
  return String(thing);
}

function decodeRecord(slice, decodeDataSeries, compressionScheme, sliceHeader, coreDataBlock, blocksByContentId, cursors, majorVersion, recordNumber) {
  var cramRecord = new CramRecord();

  cramRecord.flags = decodeDataSeries('BF');

  // note: the C data type of compressionFlags is byte in cram v1
  // and int32 in cram v2+, but that does not matter for us here
  // in javascript land.
  cramRecord.cramFlags = decodeDataSeries('CF');

  if (majorVersion > 1 && sliceHeader.content.refSeqId === -2) cramRecord.sequenceId = decodeDataSeries('RI');else cramRecord.sequenceId = sliceHeader.content.refSeqId;

  cramRecord.readLength = decodeDataSeries('RL');
  // if APDelta, will calculate the true start in a second pass
  cramRecord.alignmentStart = decodeDataSeries('AP');
  if (compressionScheme.APdelta) cramRecord.alignmentStart += cursors.lastAlignmentStart;
  cursors.lastAlignmentStart = cramRecord.alignmentStart;
  cramRecord.readGroupId = decodeDataSeries('RG');

  if (compressionScheme.readNamesIncluded) cramRecord.readName = thingToString(decodeDataSeries('RN'));

  // mate record
  if (cramRecord.isDetached()) {
    // note: the MF is a byte in 1.0, int32 in 2+, but once again this doesn't matter for javascript
    var mate = {};
    mate.flags = decodeDataSeries('MF');
    if (!compressionScheme.readNamesIncluded) {
      mate.readName = thingToString(decodeDataSeries('RN'));
    }
    mate.sequenceId = decodeDataSeries('NS');
    mate.alignmentStart = decodeDataSeries('NP');
    if (mate.flags || mate.sequenceId > -1) cramRecord.mate = mate;
    cramRecord.templateSize = decodeDataSeries('TS');
    // detachedCount++
  } else if (cramRecord.hasMateDownStream()) {
    cramRecord.mateRecordNumber = decodeDataSeries('NF') + recordNumber + 1;
  }

  // TODO: the aux tag parsing will have to be refactored if we want to support
  // cram v1
  var TLindex = decodeDataSeries('TL');
  if (TLindex < 0)
    /* TODO: check nTL: TLindex >= compressionHeader.tagEncoding.size */
    throw new CramMalformedError('invalid TL index');

  // TN = tag names
  var TN = compressionScheme.getTagNames(TLindex);
  var ntags = TN.length;

  for (var i = 0; i < ntags; i += 1) {
    var tagId = TN[i];
    var tagName = tagId.substr(0, 2);
    var tagType = tagId.substr(2, 1);

    var tagCodec = compressionScheme.getCodecForTag(tagId);
    if (!tagCodec) throw new CramMalformedError('no codec defined for auxiliary tag ' + tagId);
    var tagData = tagCodec.decode(slice, coreDataBlock, blocksByContentId, cursors);
    cramRecord.tags[tagName] = parseTagData(tagType, tagData);
  }

  if (!cramRecord.isSegmentUnmapped()) {
    // reading read features
    var /* int */readFeatureCount = decodeDataSeries('FN');
    if (readFeatureCount) {
      cramRecord.readFeatures = decodeReadFeatures(cramRecord, readFeatureCount, decodeDataSeries, compressionScheme, majorVersion);
    }

    // compute the read's true span on the reference sequence, and the end coordinate of the alignment on the reference
    var lengthOnRef = cramRecord.readLength;
    if (cramRecord.readFeatures) cramRecord.readFeatures.forEach(function (_ref3) {
      var code = _ref3.code,
          data = _ref3.data;

      if (code === 'D' || code === 'N') lengthOnRef += data;else if (code === 'I' || code === 'S') lengthOnRef -= data.length;else if (code === 'i') lengthOnRef -= 1;
    });
    if ((0, _isNan2.default)(lengthOnRef)) {
      console.warn((cramRecord.readName || cramRecord.sequenceId + ':' + cramRecord.alignmentStart) + ' record has invalid read features');
      lengthOnRef = cramRecord.readLength;
    }
    cramRecord.lengthOnRef = lengthOnRef;

    // mapping quality
    cramRecord.mappingQuality = decodeDataSeries('MQ');
    if (cramRecord.isPreservingQualityScores()) {
      var bases = new Array(cramRecord.readLength);
      for (var _i = 0; _i < bases.length; _i += 1) {
        bases[_i] = decodeDataSeries('QS');
      }cramRecord.qualityScores = bases;
    }
  } else if (cramRecord.isUnknownBases()) {
    cramRecord.readBases = null;
    cramRecord.qualityScores = null;
  } else {
    var _bases = new Array(cramRecord.readLength);
    for (var _i2 = 0; _i2 < _bases.length; _i2 += 1) {
      _bases[_i2] = decodeDataSeries('BA');
    }cramRecord.readBases = String.fromCharCode.apply(String, _bases);

    if (cramRecord.isPreservingQualityScores()) {
      for (var _i3 = 0; _i3 < _bases.length; _i3 += 1) {
        _bases[_i3] = decodeDataSeries('QS');
      }cramRecord.qualityScores = _bases;
    }
  }

  return cramRecord;
}

module.exports = decodeRecord;