'use strict';

var _values = require('babel-runtime/core-js/object/values');

var _values2 = _interopRequireDefault(_values);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _require = require('../../errors'),
    CramMalformedError = _require.CramMalformedError,
    CramBufferOverrunError = _require.CramBufferOverrunError,
    CramArgumentError = _require.CramArgumentError;

var _require2 = require('../util'),
    parseItem = _require2.parseItem,
    tinyMemoize = _require2.tinyMemoize,
    sequenceMD5 = _require2.sequenceMD5;

var Constants = require('../constants');
var decodeRecord = require('./decodeRecord');

/**
 * @private
 * Try to estimate the template length from a bunch of interrelated multi-segment reads.
 * @param {Array[CramRecord]} allRecords
 * @param {number} currentRecordNumber
 * @param {CramRecord} thisRecord
 */
function calculateMultiSegmentMatedTemplateLength(allRecords, currentRecordNumber, thisRecord) {
  function getAllMatedRecords(startRecord) {
    var records = [startRecord];
    if (startRecord.mateRecordNumber >= 0) {
      var mateRecord = allRecords[startRecord.mateRecordNumber];
      if (!mateRecord) throw new CramMalformedError('intra-slice mate record not found, this file seems malformed');
      records.push.apply(records, (0, _toConsumableArray3.default)(getAllMatedRecords(mateRecord)));
    }
    return records;
  }

  var matedRecords = getAllMatedRecords(thisRecord);
  var starts = matedRecords.map(function (r) {
    return r.alignmentStart;
  });
  var ends = matedRecords.map(function (r) {
    return r.alignmentStart + r.readLength - 1;
  });
  var estimatedTemplateLength = Math.max.apply(Math, (0, _toConsumableArray3.default)(ends)) - Math.min.apply(Math, (0, _toConsumableArray3.default)(starts)) + 1;
  if (estimatedTemplateLength >= 0) matedRecords.forEach(function (r) {
    if (r.templateLength !== undefined) throw new CramMalformedError('mate pair group has some members that have template lengths already, this file seems malformed');
    r.templateLength = estimatedTemplateLength;
  });
}

/**
 * @private
 * Attempt to calculate the `templateLength` for a pair of intra-slice paired reads.
 * Ported from htslib. Algorithm is imperfect.
 * @param {CramRecord} thisRecord
 * @param {CramRecord} mateRecord
 */
function calculateIntraSliceMatePairTemplateLength(thisRecord, mateRecord) {
  // this just estimates the template length by using the simple (non-gapped) end coordinate of each
  // read, because gapping in the alignment doesn't mean the template is longer or shorter
  var start = Math.min(thisRecord.alignmentStart, mateRecord.alignmentStart);
  var end = Math.max(thisRecord.alignmentStart + thisRecord.readLength - 1, mateRecord.alignmentStart + mateRecord.readLength - 1);
  var lengthEstimate = end - start + 1;
  thisRecord.templateLength = lengthEstimate;
  mateRecord.templateLength = lengthEstimate;
}

/**
 * @private establishes a mate-pair relationship between two records in the same slice.
 * CRAM compresses mate-pair relationships between records in the same slice down into
 * just one record having the index in the slice of its mate
 */
function associateIntraSliceMate(allRecords, currentRecordNumber, thisRecord, mateRecord) {
  if (!mateRecord) throw new CramMalformedError('could not resolve intra-slice mate pairs, file seems truncated or malformed');

  var complicatedMultiSegment = !!(mateRecord.mate || mateRecord.mateRecordNumber !== undefined && mateRecord.mateRecordNumber !== currentRecordNumber);

  thisRecord.mate = {
    sequenceId: mateRecord.sequenceId,
    alignmentStart: mateRecord.alignmentStart,
    uniqueId: mateRecord.uniqueId
  };
  if (mateRecord.readName) thisRecord.mate.readName = mateRecord.readName;

  // the mate record might have its own mate pointer, if this is some kind of
  // multi-segment (more than paired) scheme, so only relate that one back to this one
  // if it does not have any other relationship
  if (!mateRecord.mate && mateRecord.mateRecordNumber === undefined) {
    mateRecord.mate = {
      sequenceId: thisRecord.sequenceId,
      alignmentStart: thisRecord.alignmentStart,
      uniqueId: thisRecord.uniqueId
    };
    if (thisRecord.readName) mateRecord.mate.readName = thisRecord.readName;
  }

  // make sure the proper flags and cramFlags are set on both records
  // paired
  thisRecord.flags |= Constants.BAM_FPAIRED;

  // set mate unmapped if needed
  if (mateRecord.flags & Constants.BAM_FUNMAP) {
    thisRecord.flags |= Constants.BAM_FMUNMAP;
    // thisRecord.templateLength = 0
  }
  if (thisRecord.flags & Constants.BAM_FUNMAP) {}
  // thisRecord.templateLength = 0


  // set mate reversed if needed
  if (mateRecord.flags & Constants.BAM_FREVERSE) thisRecord.flags |= Constants.BAM_FMREVERSE;

  if (thisRecord.templateLength === undefined) {
    if (complicatedMultiSegment) calculateMultiSegmentMatedTemplateLength(allRecords, currentRecordNumber, thisRecord);else calculateIntraSliceMatePairTemplateLength(thisRecord, mateRecord);
  }

  // delete this last because it's used by the
  // complicated template length estimation
  delete thisRecord.mateRecordNumber;
}

var CramSlice = function () {
  function CramSlice(container, position) {
    (0, _classCallCheck3.default)(this, CramSlice);

    this.container = container;
    this.file = container.file;
    this.containerPosition = position;
  }

  // memoize


  (0, _createClass3.default)(CramSlice, [{
    key: 'getHeader',
    value: function () {
      var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
        var sectionParsers, containerHeader, header;
        return _regenerator2.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.file.getSectionParsers();

              case 2:
                sectionParsers = _context.sent;
                _context.next = 5;
                return this.container.getHeader();

              case 5:
                containerHeader = _context.sent;
                _context.next = 8;
                return this.file.readBlock(containerHeader._endPosition + this.containerPosition);

              case 8:
                header = _context.sent;

                if (!(header.contentType === 'MAPPED_SLICE_HEADER')) {
                  _context.next = 13;
                  break;
                }

                header.content = parseItem(header.content, sectionParsers.cramMappedSliceHeader.parser, 0, containerHeader._endPosition);
                _context.next = 18;
                break;

              case 13:
                if (!(header.contentType === 'UNMAPPED_SLICE_HEADER')) {
                  _context.next = 17;
                  break;
                }

                header.content = parseItem(header.content, sectionParsers.cramUnmappedSliceHeader.parser, 0, containerHeader._endPosition);
                _context.next = 18;
                break;

              case 17:
                throw new CramMalformedError('error reading slice header block, invalid content type ' + header._contentType);

              case 18:
                return _context.abrupt('return', header);

              case 19:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getHeader() {
        return _ref.apply(this, arguments);
      }

      return getHeader;
    }()

    // memoize

  }, {
    key: 'getBlocks',
    value: function () {
      var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2() {
        var header, blockPosition, blocks, i;
        return _regenerator2.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.getHeader();

              case 2:
                header = _context2.sent;

                // read all the blocks into memory and store them
                blockPosition = header._endPosition;
                blocks = new Array(header.content.numBlocks);
                i = 0;

              case 6:
                if (!(i < blocks.length)) {
                  _context2.next = 14;
                  break;
                }

                _context2.next = 9;
                return this.file.readBlock(blockPosition);

              case 9:
                blocks[i] = _context2.sent;

                blockPosition = blocks[i]._endPosition;

              case 11:
                i += 1;
                _context2.next = 6;
                break;

              case 14:
                return _context2.abrupt('return', blocks);

              case 15:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getBlocks() {
        return _ref2.apply(this, arguments);
      }

      return getBlocks;
    }()

    // no memoize

  }, {
    key: 'getCoreDataBlock',
    value: function () {
      var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3() {
        var blocks;
        return _regenerator2.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.getBlocks();

              case 2:
                blocks = _context3.sent;
                return _context3.abrupt('return', blocks[0]);

              case 4:
              case 'end':
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getCoreDataBlock() {
        return _ref3.apply(this, arguments);
      }

      return getCoreDataBlock;
    }()

    // memoize

  }, {
    key: '_getBlocksContentIdIndex',
    value: function () {
      var _ref4 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee4() {
        var blocks, blocksByContentId;
        return _regenerator2.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.getBlocks();

              case 2:
                blocks = _context4.sent;
                blocksByContentId = {};

                blocks.forEach(function (block) {
                  if (block.contentType === 'EXTERNAL_DATA') {
                    blocksByContentId[block.contentId] = block;
                  }
                });
                return _context4.abrupt('return', blocksByContentId);

              case 6:
              case 'end':
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function _getBlocksContentIdIndex() {
        return _ref4.apply(this, arguments);
      }

      return _getBlocksContentIdIndex;
    }()
  }, {
    key: 'getBlockByContentId',
    value: function () {
      var _ref5 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee5(id) {
        var blocksByContentId;
        return _regenerator2.default.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this._getBlocksContentIdIndex();

              case 2:
                blocksByContentId = _context5.sent;
                return _context5.abrupt('return', blocksByContentId[id]);

              case 4:
              case 'end':
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getBlockByContentId(_x) {
        return _ref5.apply(this, arguments);
      }

      return getBlockByContentId;
    }()
  }, {
    key: 'getReferenceRegion',
    value: function () {
      var _ref6 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee6() {
        var sliceHeader, compressionScheme, refBlock, seq;
        return _regenerator2.default.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this.getHeader();

              case 2:
                sliceHeader = _context6.sent.content;

                if (!(sliceHeader.refSeqId < 0)) {
                  _context6.next = 5;
                  break;
                }

                return _context6.abrupt('return', undefined);

              case 5:
                _context6.next = 7;
                return this.container.getCompressionScheme();

              case 7:
                compressionScheme = _context6.sent;

                if (!(sliceHeader.refBaseBlockId >= 0)) {
                  _context6.next = 17;
                  break;
                }

                refBlock = this.getBlockByContentId(sliceHeader.refBaseBlockId);

                if (refBlock) {
                  _context6.next = 12;
                  break;
                }

                throw new CramMalformedError('embedded reference specified, but reference block does not exist');

              case 12:
                if (!(sliceHeader.span > refBlock.uncompressedSize)) {
                  _context6.next = 14;
                  break;
                }

                throw new CramMalformedError('Embedded reference is too small');

              case 14:
                return _context6.abrupt('return', {
                  seq: refBlock.data.toString('utf8'),
                  start: sliceHeader.refSeqStart,
                  end: sliceHeader.refSeqStart + sliceHeader.refSeqSpan - 1,
                  span: sliceHeader.refSeqSpan
                });

              case 17:
                if (!(compressionScheme.referenceRequired || this.file.fetchReferenceSequenceCallback)) {
                  _context6.next = 26;
                  break;
                }

                if (this.file.fetchReferenceSequenceCallback) {
                  _context6.next = 20;
                  break;
                }

                throw new Error('reference sequence not embedded, and seqFetch callback not provided, cannot fetch reference sequence');

              case 20:
                _context6.next = 22;
                return this.file.fetchReferenceSequenceCallback(sliceHeader.refSeqId, sliceHeader.refSeqStart, sliceHeader.refSeqStart + sliceHeader.refSeqSpan - 1);

              case 22:
                seq = _context6.sent;

                if (!(seq.length !== sliceHeader.refSeqSpan)) {
                  _context6.next = 25;
                  break;
                }

                throw new CramArgumentError('seqFetch callback returned a reference sequence of the wrong length');

              case 25:
                return _context6.abrupt('return', {
                  seq: seq,
                  start: sliceHeader.refSeqStart,
                  end: sliceHeader.refSeqStart + sliceHeader.refSeqSpan - 1,
                  span: sliceHeader.refSeqSpan
                });

              case 26:
                return _context6.abrupt('return', undefined);

              case 27:
              case 'end':
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getReferenceRegion() {
        return _ref6.apply(this, arguments);
      }

      return getReferenceRegion;
    }()
  }, {
    key: 'getAllRecords',
    value: function getAllRecords() {
      return this.getRecords(function () {
        return true;
      });
    }
  }, {
    key: '_fetchRecords',
    value: function () {
      var _ref7 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee7() {
        var _this = this;

        var _ref8, majorVersion, compressionScheme, sliceHeader, blocksByContentId, refRegion, seq, start, end, seqMd5, storedMd5, coreDataBlock, cursors, decodeDataSeries, records, i, _i, mateRecordNumber;

        return _regenerator2.default.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this.file.getDefinition();

              case 2:
                _ref8 = _context7.sent;
                majorVersion = _ref8.majorVersion;
                _context7.next = 6;
                return this.container.getCompressionScheme();

              case 6:
                compressionScheme = _context7.sent;
                _context7.next = 9;
                return this.getHeader();

              case 9:
                sliceHeader = _context7.sent;
                _context7.next = 12;
                return this._getBlocksContentIdIndex();

              case 12:
                blocksByContentId = _context7.sent;

                if (!(majorVersion > 1 && this.file.options.checkSequenceMD5 && sliceHeader.content.refSeqId >= 0 && sliceHeader.content.md5.join('') !== '0000000000000000')) {
                  _context7.next = 23;
                  break;
                }

                _context7.next = 16;
                return this.getReferenceRegion();

              case 16:
                refRegion = _context7.sent;

                if (!refRegion) {
                  _context7.next = 23;
                  break;
                }

                seq = refRegion.seq, start = refRegion.start, end = refRegion.end;
                seqMd5 = sequenceMD5(seq);
                storedMd5 = sliceHeader.content.md5.map(function (byte) {
                  return (byte < 16 ? '0' : '') + byte.toString(16);
                }).join('');

                if (!(seqMd5 !== storedMd5)) {
                  _context7.next = 23;
                  break;
                }

                throw new CramMalformedError('MD5 checksum reference mismatch for ref ' + sliceHeader.content.refSeqId + ' pos ' + start + '..' + end + '. recorded MD5: ' + storedMd5 + ', calculated MD5: ' + seqMd5);

              case 23:
                _context7.next = 25;
                return this.getCoreDataBlock();

              case 25:
                coreDataBlock = _context7.sent;
                cursors = {
                  lastAlignmentStart: sliceHeader.content.refSeqStart || 0,
                  coreBlock: { bitPosition: 7, bytePosition: 0 },
                  externalBlocks: {
                    getCursor: function getCursor(contentId) {
                      if (!this[contentId]) this[contentId] = { bitPosition: 7, bytePosition: 0 };
                      return this[contentId];
                    }
                  }
                };

                decodeDataSeries = function decodeDataSeries(dataSeriesName) {
                  var codec = compressionScheme.getCodecForDataSeries(dataSeriesName);
                  if (!codec) throw new CramMalformedError('no codec defined for ' + dataSeriesName + ' data series');
                  // console.log(dataSeriesName, Object.getPrototypeOf(codec))
                  return codec.decode(_this, coreDataBlock, blocksByContentId, cursors);
                };

                records = new Array(sliceHeader.content.numRecords);
                i = 0;

              case 30:
                if (!(i < records.length)) {
                  _context7.next = 48;
                  break;
                }

                _context7.prev = 31;

                records[i] = decodeRecord(this, decodeDataSeries, compressionScheme, sliceHeader, coreDataBlock, blocksByContentId, cursors, majorVersion, i);
                records[i].uniqueId = sliceHeader.content.recordCounter + i + 1;
                _context7.next = 45;
                break;

              case 36:
                _context7.prev = 36;
                _context7.t0 = _context7['catch'](31);

                if (!(_context7.t0 instanceof CramBufferOverrunError)) {
                  _context7.next = 44;
                  break;
                }

                console.warn('read attempted beyond end of buffer, file seems truncated.');
                records = records.filter(function (r) {
                  return !!r;
                });
                return _context7.abrupt('break', 48);

              case 44:
                throw _context7.t0;

              case 45:
                i += 1;
                _context7.next = 30;
                break;

              case 48:

                // interpret `recordsToNextFragment` attributes to make standard `mate` objects
                // Resolve mate pair cross-references between records in this slice
                for (_i = 0; _i < records.length; _i += 1) {
                  mateRecordNumber = records[_i].mateRecordNumber;

                  if (mateRecordNumber >= 0) associateIntraSliceMate(records, _i, records[_i], records[mateRecordNumber]);
                }

                return _context7.abrupt('return', records);

              case 50:
              case 'end':
                return _context7.stop();
            }
          }
        }, _callee7, this, [[31, 36]]);
      }));

      function _fetchRecords() {
        return _ref7.apply(this, arguments);
      }

      return _fetchRecords;
    }()
  }, {
    key: 'getRecords',
    value: function () {
      var _ref9 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee9(filterFunction) {
        var _this2 = this;

        var cacheKey, recordsPromise, records, sliceHeader, singleRefId, compressionScheme, refRegions, i, seqId, refRegion, end, _i2, _seqId, _refRegion;

        return _regenerator2.default.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                // fetch the features if necessary, using the file-level feature cache
                cacheKey = this.container.filePosition + this.containerPosition;
                recordsPromise = this.file.featureCache.get(cacheKey);

                if (!recordsPromise) {
                  recordsPromise = this._fetchRecords();
                  this.file.featureCache.set(cacheKey, recordsPromise);
                }

                _context9.next = 5;
                return recordsPromise;

              case 5:
                _context9.t0 = filterFunction;
                records = _context9.sent.filter(_context9.t0);

                if (!(records.length && this.file.fetchReferenceSequenceCallback)) {
                  _context9.next = 21;
                  break;
                }

                _context9.next = 10;
                return this.getHeader();

              case 10:
                sliceHeader = _context9.sent;

                if (!(sliceHeader.content.refSeqId >= 0 || // single-ref slice
                sliceHeader.content.refSeqId === -2 // multi-ref slice
                )) {
                  _context9.next = 21;
                  break;
                }

                singleRefId = sliceHeader.content.refSeqId >= 0 ? sliceHeader.content.refSeqId : undefined;
                _context9.next = 15;
                return this.container.getCompressionScheme();

              case 15:
                compressionScheme = _context9.sent;
                refRegions = {}; // seqId => { start, end, seq }

                // iterate over the records to find the spans of the reference sequences we need to fetch

                for (i = 0; i < records.length; i += 1) {
                  seqId = singleRefId !== undefined ? singleRefId : records[i].sequenceId;
                  refRegion = refRegions[seqId];

                  if (!refRegion) {
                    refRegion = {
                      id: seqId,
                      start: records[i].alignmentStart,
                      end: -Infinity
                    };
                    refRegions[seqId] = refRegion;
                  }

                  end = records[i].alignmentStart + (records[i].lengthOnRef || records[i].readLength) - 1;

                  if (end > refRegion.end) refRegion.end = end;
                  if (records[i].alignmentStart < refRegion.start) refRegion.start = records[i].alignmentStart;
                }

                // fetch the `seq` for all of the ref regions
                _context9.next = 20;
                return _promise2.default.all((0, _values2.default)(refRegions).map(function () {
                  var _ref10 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee8(refRegion) {
                    return _regenerator2.default.wrap(function _callee8$(_context8) {
                      while (1) {
                        switch (_context8.prev = _context8.next) {
                          case 0:
                            if (!(refRegion.id !== -1 && refRegion.start <= refRegion.end)) {
                              _context8.next = 4;
                              break;
                            }

                            _context8.next = 3;
                            return _this2.file.fetchReferenceSequenceCallback(refRegion.id, refRegion.start, refRegion.end);

                          case 3:
                            refRegion.seq = _context8.sent;

                          case 4:
                          case 'end':
                            return _context8.stop();
                        }
                      }
                    }, _callee8, _this2);
                  }));

                  return function (_x3) {
                    return _ref10.apply(this, arguments);
                  };
                }()));

              case 20:

                // now decorate all the records with them
                for (_i2 = 0; _i2 < records.length; _i2 += 1) {
                  _seqId = singleRefId !== undefined ? singleRefId : records[_i2].sequenceId;
                  _refRegion = refRegions[_seqId];

                  if (_refRegion && _refRegion.seq) {
                    records[_i2].addReferenceSequence(_refRegion, compressionScheme);
                  }
                }

              case 21:
                return _context9.abrupt('return', records);

              case 22:
              case 'end':
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function getRecords(_x2) {
        return _ref9.apply(this, arguments);
      }

      return getRecords;
    }()
  }]);
  return CramSlice;
}();

// memoize several methods in the class for performance


'getHeader getBlocks _getBlocksContentIdIndex'.split(' ').forEach(function (method) {
  return tinyMemoize(CramSlice, method);
});

module.exports = CramSlice;