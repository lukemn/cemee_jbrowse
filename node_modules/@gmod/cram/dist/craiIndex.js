'use strict';

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _entries = require('babel-runtime/core-js/object/entries');

var _entries2 = _interopRequireDefault(_entries);

var _parseInt = require('babel-runtime/core-js/number/parse-int');

var _parseInt2 = _interopRequireDefault(_parseInt);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var promisify = require('util.promisify');
var zlib = require('zlib');

var gunzip = promisify(zlib.gunzip);

var _require = require('./io'),
    open = _require.open;

var _require2 = require('./errors'),
    CramMalformedError = _require2.CramMalformedError;

function addRecordToIndex(index, record) {
  if (record.some(function (el) {
    return el === undefined;
  })) {
    throw new CramMalformedError('invalid .crai index file');
  }

  var _record = (0, _slicedToArray3.default)(record, 6),
      seqId = _record[0],
      start = _record[1],
      span = _record[2],
      containerStart = _record[3],
      sliceStart = _record[4],
      sliceBytes = _record[5];

  if (!index[seqId]) index[seqId] = [];

  index[seqId].push({
    start: start,
    span: span,
    containerStart: containerStart,
    sliceStart: sliceStart,
    sliceBytes: sliceBytes
  });
}

var CraiIndex = function () {
  // A CRAM index (.crai) is a gzipped tab delimited file containing the following columns:
  // 1. Sequence id
  // 2. Alignment start
  // 3. Alignment span
  // 4. Container start byte position in the file
  // 5. Slice start byte position in the container data (‘blocks’)
  // 6. Slice size in bytes
  // Each line represents a slice in the CRAM file. Please note that all slices must be listed in index file.

  /**
   *
   * @param {object} args
   * @param {string} [args.path]
   * @param {string} [args.url]
   * @param {FileHandle} [args.filehandle]
   */
  function CraiIndex(args) {
    (0, _classCallCheck3.default)(this, CraiIndex);

    var filehandle = open(args.url, args.path, args.filehandle);
    this.readFile = filehandle.readFile.bind(filehandle);
    this.index = this.parseIndex();
  }

  (0, _createClass3.default)(CraiIndex, [{
    key: 'parseIndex',
    value: function parseIndex() {
      var index = {};
      return this.readFile().then(function (data) {
        if (data[0] === 31 && data[1] === 139) return gunzip(data);
        return data;
      }).then(function (uncompressedBuffer) {
        // interpret the text as regular ascii, since it is
        // supposed to be only digits and whitespace characters
        // this is written in a deliberately low-level fashion for performance,
        // because some .crai files can be pretty large.
        var currentRecord = [];
        var currentString = '';
        for (var i = 0; i < uncompressedBuffer.length; i += 1) {
          var charCode = uncompressedBuffer[i];
          if (charCode >= 48 && charCode <= 57 || /* 0-9 */!currentString && charCode === 45 /* leading - */
          ) {
              currentString += String.fromCharCode(charCode);
            } else if (charCode === 9 /* \t */) {
              currentRecord.push((0, _parseInt2.default)(currentString, 10));
              currentString = '';
            } else if (charCode === 10 /* \n */) {
              currentRecord.push((0, _parseInt2.default)(currentString, 10));
              currentString = '';
              addRecordToIndex(index, currentRecord);
              currentRecord = [];
            } else if (charCode !== 13 /* \r */ && charCode !== 32 /* space */) {
              // if there are other characters in the file besides
              // space and \r, something is wrong.
              throw new CramMalformedError('invalid .crai index file');
            }
        }

        // if the file ends without a \n, we need to flush our buffers
        if (currentString) {
          currentRecord.push((0, _parseInt2.default)(currentString, 10));
        }
        if (currentRecord.length === 6) {
          addRecordToIndex(index, currentRecord);
        }

        // sort each of them by start
        (0, _entries2.default)(index).forEach(function (_ref) {
          var _ref2 = (0, _slicedToArray3.default)(_ref, 2),
              seqId = _ref2[0],
              entries = _ref2[1];

          index[seqId] = entries.sort(function (a, b) {
            return a.start - b.start || a.span - b.span;
          });
        });
        return index;
      });
    }
  }, {
    key: 'getIndex',
    value: function getIndex() {
      return this.index;
    }

    /**
     * @param {number} seqId
     * @returns {Promise} true if the index contains entries for
     * the given reference sequence ID, false otherwise
     */

  }, {
    key: 'hasDataForReferenceSequence',
    value: function () {
      var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(seqId) {
        return _regenerator2.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.index;

              case 2:
                _context.t0 = seqId;
                return _context.abrupt('return', !!_context.sent[_context.t0]);

              case 4:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function hasDataForReferenceSequence(_x) {
        return _ref3.apply(this, arguments);
      }

      return hasDataForReferenceSequence;
    }()

    /**
     * fetch index entries for the given range
     *
     * @param {number} seqId
     * @param {number} queryStart
     * @param {number} queryEnd
     *
     * @returns {Promise} promise for
     * an array of objects of the form
     * `{start, span, containerStart, sliceStart, sliceBytes }`
     */

  }, {
    key: 'getEntriesForRange',
    value: function () {
      var _ref4 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(seqId, queryStart, queryEnd) {
        var seqEntries, len, compare, lowerBound, upperBound, searchPosition, lastSearchPosition, nextSearchDirection, overlapStart, overlapEnd;
        return _regenerator2.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.index;

              case 2:
                _context2.t0 = seqId;
                seqEntries = _context2.sent[_context2.t0];

                if (seqEntries) {
                  _context2.next = 6;
                  break;
                }

                return _context2.abrupt('return', []);

              case 6:
                len = seqEntries.length;

                // binary search to find an entry that
                // overlaps the range, then extend backward
                // and forward from that

                compare = function compare(entry) {
                  var entryStart = entry.start;
                  var entryEnd = entry.start + entry.span;
                  if (entryStart >= queryEnd) return -1; // entry is ahead of query
                  if (entryEnd <= queryStart) return 1; // entry is behind query
                  return 0; // entry overlaps query
                };

                lowerBound = 0;
                upperBound = len - 1;
                searchPosition = Math.floor(len / 2);
                lastSearchPosition = -1;
                nextSearchDirection = void 0;

              case 13:
                nextSearchDirection = compare(seqEntries[searchPosition]);

                if (!(nextSearchDirection > 0)) {
                  _context2.next = 18;
                  break;
                }

                lowerBound = searchPosition;
                _context2.next = 23;
                break;

              case 18:
                if (!(nextSearchDirection < 0)) {
                  _context2.next = 22;
                  break;
                }

                upperBound = searchPosition;
                _context2.next = 23;
                break;

              case 22:
                return _context2.abrupt('break', 29);

              case 23:

                lastSearchPosition = searchPosition;
                searchPosition = Math.floor((upperBound + lowerBound) / 2);

                if (!(lastSearchPosition === searchPosition)) {
                  _context2.next = 27;
                  break;
                }

                return _context2.abrupt('return', []);

              case 27:
                _context2.next = 13;
                break;

              case 29:

                // now extend backward
                overlapStart = searchPosition;

                while (overlapStart && !compare(seqEntries[overlapStart - 1])) {
                  overlapStart -= 1;
                } // and then extend forward
                overlapEnd = searchPosition;

                while (overlapEnd < len - 1 && !compare(seqEntries[overlapEnd + 1])) {
                  overlapEnd += 1;
                }return _context2.abrupt('return', seqEntries.slice(overlapStart, overlapEnd + 1));

              case 34:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getEntriesForRange(_x2, _x3, _x4) {
        return _ref4.apply(this, arguments);
      }

      return getEntriesForRange;
    }()
  }]);
  return CraiIndex;
}();

module.exports = CraiIndex;