'use strict';var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);var _createClass2 = require('babel-runtime/helpers/createClass');var _createClass3 = _interopRequireDefault(_createClass2);var _isNan = require('babel-runtime/core-js/number/is-nan');var _isNan2 = _interopRequireDefault(_isNan);var _keys = require('babel-runtime/core-js/object/keys');var _keys2 = _interopRequireDefault(_keys);function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}function parseCacheControl(field) {
  if (typeof field !== 'string') {
    return {};
  }

  var parsed = {};
  var invalid = field.toLowerCase().replace(
  // eslint-disable-next-line no-control-regex,no-useless-escape
  /(?:^|(?:\s*,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g,
  function (match, fieldName, three, four) {
    var value = three || four;
    parsed[fieldName] = value ? value.toLowerCase() : true;
    return '';
  });


  if (invalid) return {};

  // parse any things that seem to be numbers
  (0, _keys2.default)(parsed).forEach(function (key) {
    if (/^[\d]+$/.test(parsed[key])) {
      try {
        var num = parseInt(parsed[key], 10);
        if (!(0, _isNan2.default)(num)) {
          parsed[key] = num;
        }
      } catch (e) {
        /* ignore */
      }
    }
  });

  return parsed;
}var

CacheSemantics = function () {
  function CacheSemantics(_ref) {var minimumTTL = _ref.minimumTTL;(0, _classCallCheck3.default)(this, CacheSemantics);
    this.minimumTTL = minimumTTL;
  }(0, _createClass3.default)(CacheSemantics, [{ key: 'calculateChunkExpirationDate', value: function calculateChunkExpirationDate(

    chunkResponse) {var _chunkResponse$header =
      chunkResponse.headers,headers = _chunkResponse$header === undefined ? {} : _chunkResponse$header,requestDate = chunkResponse.requestDate,responseDate = chunkResponse.responseDate;
      var baselineDate = responseDate || requestDate;
      if (!baselineDate) {
        if (!headers.date) return undefined;
        baselineDate = new Date(headers.date);
      }

      var basePlus = function basePlus(ttl) {return new Date(baselineDate.getTime() + ttl);};

      // results that are not really cacheable expire after the minimum time to live
      if (/\bno-cache\b/.test(headers.pragma)) return basePlus(this.minimumTTL);

      var cacheControl = parseCacheControl(headers['cache-control']);
      if (
      cacheControl['no-cache'] ||
      cacheControl['no-store'] ||
      cacheControl['must-revalidate'])

      return basePlus(this.minimumTTL);

      if (cacheControl['max-age'] !== undefined) {
        var ttl = cacheControl['max-age'] * 1000; // max-age is in seconds
        return basePlus(Math.max(ttl, this.minimumTTL));
      } else if (this._coerceToDate(headers.expires)) {
        return this._coerceToDate(headers.expires);
      } else if (this._coerceToDate(headers['last-modified'])) {
        var lastModified = this._coerceToDate(headers['last-modified']);
        var _ttl = (baselineDate.getTime() - lastModified.getTime()) / 10;
        return basePlus(_ttl);
      }

      // otherwise, we just cache forever
      return undefined;
    } }, { key: '_coerceToDate', value: function _coerceToDate(

    thing) {
      if (thing) {
        if (thing instanceof Date) return thing;
        if (typeof thing === 'string' || typeof thing === 'number')
        return new Date(thing);
      }
      return undefined;
    }

    /**
       * check whether a cached chunk response is still valid and can be used
       * @param {object} chunkResponse
       * @returns {boolean}
       */ }, { key: 'cachedChunkIsValid', value: function cachedChunkIsValid(
    chunkResponse) {
      var expiration = this.calculateChunkExpirationDate(chunkResponse);
      return !expiration || new Date() <= expiration;
    }

    /**
       * check whether the response for this chunk fetch can be cached
       * @param {object} chunkResponse
       * @returns {boolean}
       */ }, { key: 'chunkIsCacheable', value: function chunkIsCacheable()
    {
      // right now, we are caching everything, we just give it a very short
      // time to live if it's not supposed to be cached
      return true;
    } }]);return CacheSemantics;}();

module.exports = { CacheSemantics: CacheSemantics, parseCacheControl: parseCacheControl };