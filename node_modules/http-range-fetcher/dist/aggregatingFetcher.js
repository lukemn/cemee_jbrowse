"use strict";var _promise = require("babel-runtime/core-js/promise");var _promise2 = _interopRequireDefault(_promise);var _slicedToArray2 = require("babel-runtime/helpers/slicedToArray");var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);var _entries = require("babel-runtime/core-js/object/entries");var _entries2 = _interopRequireDefault(_entries);var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);var _createClass2 = require("babel-runtime/helpers/createClass");var _createClass3 = _interopRequireDefault(_createClass2);function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };} /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * takes fetch requests and aggregates them at a certain time frequency
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */var
AggregatingFetcher = function () {
  /**
                                   *
                                   * @param {object} params
                                   * @param {number} [params.frequency] number of milliseconds to wait for requests to aggregate
                                   */
  function AggregatingFetcher(_ref)




  {var _ref$frequency = _ref.frequency,frequency = _ref$frequency === undefined ? 100 : _ref$frequency,fetch = _ref.fetch,_ref$maxExtraSize = _ref.maxExtraSize,maxExtraSize = _ref$maxExtraSize === undefined ? 32000 : _ref$maxExtraSize,_ref$maxFetchSize = _ref.maxFetchSize,maxFetchSize = _ref$maxFetchSize === undefined ? 1000000 : _ref$maxFetchSize;(0, _classCallCheck3.default)(this, AggregatingFetcher);
    this.requestQueues = {}; // url => array of requests
    this.fetchCallback = fetch;
    this.frequency = frequency;
    this.maxExtraSize = maxExtraSize;
    this.maxFetchSize = maxFetchSize;
  }(0, _createClass3.default)(AggregatingFetcher, [{ key: "_canAggregate", value: function _canAggregate(

    requestGroup, request) {
      return (
        // the fetches overlap, or come close
        request.start <= requestGroup.end + this.maxExtraSize &&
        // aggregating would not result in a fetch that is too big
        request.end - request.start + requestGroup.end - requestGroup.start <
        this.maxFetchSize);

    }

    // dispatch a request group as a single request
    // and then slice the result back up to satisfy
    // the individual requests
  }, { key: "_dispatch", value: function _dispatch(_ref2) {var url = _ref2.url,start = _ref2.start,end = _ref2.end,requests = _ref2.requests;
      this.fetchCallback(url, start, end - 1).then(
      function (response) {
        var data = response.buffer;
        requests.forEach(function (_ref3) {var reqStart = _ref3.start,reqEnd = _ref3.end,resolve = _ref3.resolve;
          // remember Buffer.slice does not copy, it creates
          // an offset child buffer pointing to the same data
          resolve({
            headers: response.headers,
            buffer: data.slice(reqStart - start, reqEnd - start) });

        });
      },
      function (err) {return requests.forEach(function (_ref4) {var reject = _ref4.reject;return reject(err);});});

    } }, { key: "_aggregateAndDispatch", value: function _aggregateAndDispatch()

    {var _this = this;
      (0, _entries2.default)(this.requestQueues).forEach(function (_ref5) {var _ref6 = (0, _slicedToArray3.default)(_ref5, 2),url = _ref6[0],requests = _ref6[1];
        if (!requests || !requests.length) return;
        // console.log(url, requests)
        // aggregate the requests in this url's queue
        var sortedRequests = requests.sort(function (a, b) {return a.start - b.start;});
        var currentRequestGroup = void 0;
        do {
          var next = sortedRequests.shift();
          if (
          currentRequestGroup &&
          _this._canAggregate(currentRequestGroup, next))
          {
            // aggregate it
            currentRequestGroup.requests.push(next);
            currentRequestGroup.end = next.end;
          } else {
            // out of range, dispatch the current request group
            if (currentRequestGroup) _this._dispatch(currentRequestGroup);
            currentRequestGroup = {
              requests: [next],
              url: url,
              start: next.start,
              end: next.end };

          }
        } while (sortedRequests.length);

        if (currentRequestGroup) _this._dispatch(currentRequestGroup);
      });
    } }, { key: "_enQueue", value: function _enQueue(

    url, request) {
      if (!this.requestQueues[url]) this.requestQueues[url] = [];
      this.requestQueues[url].push(request);
    }

    /**
       *
       * @param {string} url
       * @param {number} start 0-based half-open
       * @param {number} end 0-based half-open
       */ }, { key: "fetch", value: function fetch(
    url, start, end) {var _this2 = this;
      return new _promise2.default(function (resolve, reject) {
        _this2._enQueue(url, { start: start, end: end, resolve: resolve, reject: reject });
        if (!_this2.timeout) {
          _this2.timeout = setTimeout(function () {
            _this2.timeout = undefined;
            _this2._aggregateAndDispatch();
          }, _this2.frequency);
        }
      });
    } }]);return AggregatingFetcher;}();


module.exports = AggregatingFetcher;